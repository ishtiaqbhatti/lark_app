This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-10-28T20:50:59.546Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

# Directory Structure
```
src/
  components/
    layout/
      AppSidebar.jsx
      MainLayout.jsx
    ContentDiffViewer.jsx
    CostConfirmationModal.jsx
    GlobalJobTracker.jsx
    JobStatusIndicator.jsx
    PromptTemplateEditor.jsx
  context/
    AuthContext.jsx
    ClientContext.jsx
    JobContext.jsx
    NotificationContext.jsx
  hooks/
    useClient.js
    useDebounce.js
  pages/
    ActivityLog/
      ActivityLogPage.jsx
    Auth/
      LoginPage.jsx
    BlogPage/
      BlogPage.css
      BlogPage.jsx
    ClientDashboard/
      AddNewClientModal.jsx
      ClientDashboardPage.jsx
    ClientSettings/
      ClientSettingsPage.jsx
    Dashboard/
      DashboardPage.jsx
    DiscoveryPage/
      components/
        DiscoveryForm.jsx
        DiscoveryHistory.jsx
        DiscoveryStatsBreakdown.jsx
        FilterBuilder.jsx
        FunnelChart.css
        FunnelChart.jsx
        PieChartCard.jsx
        RunDetailsModal.jsx
        RunDetailsPage.jsx
      hooks/
        useDiscoveryFilters.js
        useDiscoveryRuns.js
      DiscoveryPage.jsx
    NotFoundPage/
      NotFoundPage.jsx
    OpportunitiesPage/
      components/
        ScoreBreakdownModal.jsx
      hooks/
        useOpportunities.js
        useOpportunities.refactored.js
      OpportunitiesPage.css
      OpportunitiesPage.jsx
    opportunity-detail-page/
      components/
        ActionCenter.jsx
        AdditionalInsights.jsx
        ArticlePreview.jsx
        CompetitorBacklinks.jsx
        ContentAuditCard.jsx
        ContentBlueprint.jsx
        ErrorMessage.jsx
        ExecutiveSummary.jsx
        FactorsCard.jsx
        FeaturedSnippetCard.jsx
        GrowthTrend.jsx
        IntentAnalysis.jsx
        KeywordMetrics.jsx
        MetaInfo.jsx
        NoData.jsx
        OpportunityHeader.jsx
        QualificationInfo.jsx
        RecommendedStrategyCard.jsx
        SerpAnalysis.jsx
        SerpVitals.jsx
        SocialMediaTab.jsx
        StrategicNotes.jsx
        StrategicScoreBreakdown.jsx
        VerdictCard.jsx
        WorkflowStatusAlert.jsx
        WorkflowTracker.jsx
      hooks/
        useOpportunityData.js
      index.jsx
    RunDetailsPage/
      RunDetailsPage.jsx
    Settings/
      tabs/
        AiContentSettingsTab.jsx
        DiscoverySettingsTab.jsx
        ScoringWeightsTab.jsx
      SettingsPage.jsx
  services/
    apiClient.js
    authService.js
    clientService.js
    clientSettingsService.js
    discoveryService.js
    jobsService.js
    opportunitiesService.js
    orchestratorService.js
    settingsService.js
  App.jsx
  index.css
  main.jsx
.dockerignore
.eslintignore
.eslintrc.json
Dockerfile
index.html
nginx.conf
package.json
vite.config.js
```

# Files

## File: src/components/layout/AppSidebar.jsx
```javascript
import React from 'react';
import { Layout, Menu, Typography } from 'antd';
import { RocketOutlined, BulbOutlined } from '@ant-design/icons';
import { NavLink, useLocation } from 'react-router-dom';

const { Sider } = Layout;
const { Title } = Typography;

// Menu items for the sidebar
const menuItems = [
  {
    key: '/',
    icon: <RocketOutlined />,
    label: <NavLink to="/">Discovery</NavLink>,
  },
  {
    key: '/opportunities',
    icon: <BulbOutlined />,
    label: <NavLink to="/opportunities">Opportunities</NavLink>,
  },
  // Add other navigation links here as you build new pages
  // {
  //   key: '/pipeline',
  //   icon: <BranchesOutlined />,
  //   label: <NavLink to="/pipeline">Content Pipeline</NavLink>,
  // },
];

const AppSidebar = () => {
  const location = useLocation(); // To highlight the active menu item

  return (
    <Sider collapsible breakpoint="lg" collapsedWidth="0">
      <div style={{ padding: '16px', textAlign: 'center' }}>
        <Title level={4} style={{ color: 'white', margin: 0 }}>Content AI</Title>
      </div>
      <Menu
        theme="dark"
        mode="inline"
        selectedKeys={[location.pathname]} // Highlight the current path
        items={menuItems}
      />
    </Sider>
  );
};

export default AppSidebar;
```

## File: src/components/layout/MainLayout.jsx
```javascript
import { Menu, Layout, Typography, Button, Space, Select, Spin, Input, Card, Tag } from 'antd'; // Add Button and Typography
import { DashboardOutlined, SettingOutlined, LogoutOutlined, BulbOutlined, RocketOutlined, ClockCircleOutlined } from '@ant-design/icons'; // Add new icons
import { NavLink, useLocation, useNavigate, Outlet } from 'react-router-dom'; // Add useNavigate
import { useAuth } from '../../context/AuthContext'; // NEW
import { useClient } from '../../context/ClientContext'; // NEW
import { getClients, searchAllAssets } from '../../services/clientService'; // NEW
import { useQuery } from 'react-query'; // NEW
import useDebounce from '../../hooks/useDebounce'; // Assuming you have a useDebounce hook
import React, { useState, useEffect } from 'react';

const { Sider, Header, Content } = Layout;
const { Title, Text } = Typography;

// REPLACE the existing `menuItems` definition with this:
const menuItems = [
  {
    key: '/dashboard',
    icon: <DashboardOutlined />,
    label: <NavLink to="/dashboard">Dashboard</NavLink>,
  },
  {
    key: '/opportunities',
    icon: <BulbOutlined />,
    label: <NavLink to="/opportunities">Opportunities</NavLink>,
  },
  {
    key: '/discovery',
    icon: <RocketOutlined />,
    label: <NavLink to="/discovery">Discovery</NavLink>,
  },
  {
    key: '/activity-log',
    icon: <ClockCircleOutlined />,
    label: <NavLink to="/activity-log">Activity Log</NavLink>,
  },
  {
    key: '/settings',
    icon: <SettingOutlined />,
    label: <NavLink to="/settings">Settings</NavLink>,
  },
];

// REPLACE the existing `MainLayout` component with this:
const MainLayout = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { logout } = useAuth();
  const { clientId, setClientId } = useClient();
  const { data: clients = [], isLoading: isLoadingClients } = useQuery('clients', getClients);

  const [globalSearchResults, setGlobalSearchResults] = useState([]);
  const [isSearchLoading, setIsSearchLoading] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    const handleGlobalSearch = async () => {
      if (!debouncedSearchTerm || debouncedSearchTerm.length < 3 || !clientId) {
        setGlobalSearchResults([]);
        return;
      }
      setIsSearchLoading(true);
      try {
        const results = await searchAllAssets(clientId, debouncedSearchTerm);
        setGlobalSearchResults(results);
      } catch (error) {
        console.error("Global search failed:", error);
        setGlobalSearchResults([]);
      } finally {
        setIsSearchLoading(false);
      }
    };

    handleGlobalSearch();
  }, [debouncedSearchTerm, clientId]);

  const handleSearchResultClick = (e) => {
    const [type, id] = e.key.split('-');
    setGlobalSearchResults([]); // Clear search results after selection
    if (type === 'opportunity') navigate(`/opportunities/${id}`);
    if (type === 'discovery_run') navigate(`/discovery/run/${id}`);
    // Add more navigation logic for other types if needed
  };

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  const handleSelectClientFromDropdown = (value) => {
    setClientId(value);
    localStorage.setItem('clientId', value);
    navigate('/dashboard'); // CRITICAL FIX: Redirect to a safe page (dashboard) after switching client
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider collapsible breakpoint="lg" collapsedWidth="0">
        <div style={{ padding: '16px', textAlign: 'center' }}>
          <Title level={4} style={{ color: 'white', margin: 0 }}>Content AI</Title>
          <Text style={{ color: 'rgba(255,255,255,0.6)', fontSize: '0.8em' }}>
            {isLoadingClients ? 'Loading Clients...' : `Client: ${clients.find(c => c.client_id === clientId)?.client_name || clientId}`}
          </Text>
        </div>
        <Menu
          theme="dark"
          mode="inline"
          selectedKeys={[location.pathname]}
          items={menuItems}
        />
      </Sider>
      <Layout>
        <Header style={{ background: '#fff', padding: '0 16px', display: 'flex', justifyContent: 'space-between', alignItems: 'center', borderBottom: '1px solid #f0f0f0' }}>
<div style={{ padding: '0 16px', color: 'rgba(255, 255, 255, 0.65)' }}>
  <Space>
    {isLoadingClients ? <Spin size="small" /> : `Client: ${clients.find(c => c.client_id === clientId)?.client_name || 'N/A'}`}
  </Space>
</div>
          <div style={{ flexGrow: 1, margin: '0 20px', maxWidth: '400px' }}>
            <Input.Search
              placeholder="Search keywords, opportunities, runs..."
              onChange={(e) => setSearchTerm(e.target.value)}
              style={{ width: '100%' }}
              allowClear
              loading={isSearchLoading}
            />
            {globalSearchResults.length > 0 && (
              <Card
                size="small"
                style={{ position: 'absolute', zIndex: 100, width: 'inherit', marginTop: '5px' }}
                bodyStyle={{ padding: '0px' }}
              >
                <Menu
  onClick={handleSearchResultClick}
  style={{ width: '100%', borderRight: 0 }}
>
  {globalSearchResults.map(item => {
    const key = `${item.type}-${item.id}`;
    let labelText = item.keyword || item.name || 'N/A';
    let typeTag = item.type.replace(/_/g, ' ').toUpperCase();

    return (
      <Menu.Item key={key} icon={item.type === 'opportunity' ? <BulbOutlined /> : <RocketOutlined />}>
        <Space size="small">
          <Text ellipsis={true} style={{ maxWidth: '200px' }}>{labelText}</Text>
          <Tag color={item.type === 'opportunity' ? 'blue' : 'purple'}>{typeTag}</Tag>
        </Space>
      </Menu.Item>
    );
  })}
</Menu>
              </Card>
            )}
          </div>
          <Space>
            <Select
              value={clientId}
              style={{ width: 180 }}
              onChange={handleSelectClientFromDropdown}
              loading={isLoadingClients}
              disabled={isLoadingClients || clients.length === 0}
              options={clients.map(c => ({ value: c.client_id, label: c.client_name }))}
            />
            <Button icon={<LogoutOutlined />} onClick={handleLogout}>Logout</Button>
          </Space>
        </Header>
        <Content style={{ margin: '16px' }}>
          <Outlet />
        </Content>
      </Layout>
    </Layout>
  );
};

export default MainLayout;
```

## File: src/components/ContentDiffViewer.jsx
```javascript
// This is a new file. Create it with the following content:
// You'll need to install react-diff-viewer: npm install react-diff-viewer
import React from 'react';
import DiffViewer from 'react-diff-viewer';
import { Typography } from 'antd';

const { Text } = Typography;

const ContentDiffViewer = ({ oldValue, newValue, oldTitle = "Previous Version", newTitle = "Current Version" }) => {
  if (!oldValue && !newValue) {
    return <Text type="secondary">No content to compare.</Text>;
  }
  if (oldValue === newValue) {
    return <Text type="success">Content is identical.</Text>;
  }

  return (
    <DiffViewer
      oldValue={oldValue || ''}
      newValue={newValue || ''}
      splitView={true}
      leftTitle={oldTitle}
      rightTitle={newTitle}
      showDiffOnly={false} // Show entire file with diffs highlighted
      use={true} // Enable styling
      styles={{
        variables: {
          dark: {
            diffViewerBackground: '#262626',
            diffViewerColor: '#f0f2f5',
            addedBackground: '#003a29',
            removedBackground: '#320a0b',
            wordAddedBackground: '#006d3d',
            wordRemovedBackground: '#9e2b2f',
          },
        },
        diffContainer: {
          fontSize: '12px',
          fontFamily: 'monospace',
        },
        line: {
          wordBreak: 'break-word',
        }
      }}
    />
  );
};

export default ContentDiffViewer;
```

## File: src/components/CostConfirmationModal.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Modal, Typography, Spin, Alert, List } from 'antd';
import { useQuery } from 'react-query';
import { estimateActionCost } from '../services/orchestratorService'; // NEW

const { Title, Text, Paragraph } = Typography;

const CostConfirmationModal = ({ open, onCancel, onConfirm, opportunityId, actionType }) => {
  const { data: costEstimate, isLoading, isError, error } = useQuery(
    ['costEstimate', opportunityId, actionType],
    () => estimateActionCost(opportunityId, actionType),
    {
      enabled: open && !!opportunityId && !!actionType, // Only fetch when modal is open
      staleTime: 5 * 60 * 1000, // Cost estimates don't change frequently
    }
  );

  const getActionTitle = (type) => {
    switch (type) {
      case 'analyze': return 'Run Deep-Dive Analysis';
      case 'generate': return 'Generate Full Content Package';
      case 'refresh': return 'Refresh Content (Analysis & Generation)';
      case 'validate': return 'Run Live SERP Validation';
      default: return 'Perform Action';
    }
  };

  return (
    <Modal
      title={getActionTitle(actionType)}
      open={open}
      onCancel={onCancel}
      onOk={onConfirm}
      confirmLoading={isLoading}
      okText="Confirm & Proceed"
      cancelText="Cancel"
    >
      {isLoading ? (
        <Spin tip="Estimating API costs..." />
      ) : isError ? (
        <Alert
          message="Error Estimating Cost"
          description={error?.message || 'Could not fetch cost estimation. Proceed with caution.'}
          type="error"
          showIcon
        />
      ) : (
        <>
          <Paragraph>
            This action will incur API costs. Please review the estimate below before proceeding.
          </Paragraph>
          <List
            size="small"
            bordered
            dataSource={costEstimate?.breakdown || []}
            renderItem={item => (
    <List.Item
        actions={[
            <Text key="cost" strong>
                {item.cost ? `$${item.cost.toFixed(4)}` : item.cost === 0 ? '$0.0000' : 'N/A'}
            </Text>
        ]}
    >
        <List.Item.Meta
            title={item.service}
            description={item.details}
        />
    </List.Item>
)}
footer={
    <Paragraph strong style={{ fontSize: '1.2em' }}>Estimated Total: <Text code>${costEstimate?.total_cost?.toFixed(4) || '0.0000'}</Text> USD</Paragraph>
}
/>
<Alert
            message="This is an estimate. Actual costs may vary."
            type="info"
            showIcon
            style={{ marginTop: '16px' }}
          />
        </>
      )}
    </Modal>
  );
};

export default CostConfirmationModal;
```

## File: src/components/GlobalJobTracker.jsx
```javascript
import React from 'react';
import { Alert, Spin } from 'antd';
import { useJobs } from '../context/JobContext';
import { CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';

const GlobalJobTracker = () => {
  const { activeJobs } = useJobs();

  if (Object.keys(activeJobs).length === 0) {
    return null;
  }

  return (
    <div style={{ position: 'fixed', bottom: 24, right: 24, zIndex: 1000, display: 'flex', flexDirection: 'column', gap: '16px' }}>
      {Object.entries(activeJobs).map(([jobId, job]) => {
        let icon, type;
        switch (job.status) {
          case 'running':
            icon = <Spin />;
            type = 'info';
            break;
          case 'completed':
            icon = <CheckCircleOutlined />;
            type = 'success';
            break;
          case 'failed':
            icon = <CloseCircleOutlined />;
            type = 'error';
            break;
          default:
            icon = <Spin />;
            type = 'info';
        }

        return (
          <Alert
            key={jobId}
            message={`Job Status: ${job.status.charAt(0).toUpperCase() + job.status.slice(1)}`}
            description={job.message}
            type={type}
            showIcon
            icon={icon}
            style={{ boxShadow: '0 2px 8px rgba(0,0,0,0.15)' }}
          />
        );
      })}
    </div>
  );
};

export default GlobalJobTracker;
```

## File: src/components/JobStatusIndicator.jsx
```javascript
import React from 'react';
import { useQuery } from 'react-query';
import { getJobStatus } from '../services/orchestratorService'; // This service function needs to be created
import { Progress, Tag, Tooltip } from 'antd';
import { LoadingOutlined, CheckCircleOutlined, CloseCircleOutlined, ClockCircleOutlined, PauseCircleOutlined } from '@ant-design/icons'; // ADD PauseCircleOutlined

const JobStatusIndicator = ({ jobId }) => {
  const { data: job, isLoading } = useQuery(
    ['jobStatus', jobId],
    () => getJobStatus(jobId),
    {
      refetchInterval: (data) => (data?.status === 'running' || data?.status === 'pending' || data?.status === 'paused' ? 3000 : false), // Refetch for paused jobs too
      enabled: !!jobId,
    }
  );

  if (isLoading && !job) return <Tag icon={<LoadingOutlined spin />}>Loading...</Tag>;
  if (!job) return <Tag>Unknown</Tag>;

  const statusConfig = {
    pending: { icon: <LoadingOutlined />, color: 'default', text: 'Pending' },
    running: { icon: <LoadingOutlined spin />, color: 'processing', text: job.result?.step || 'Running...' },
    completed: { icon: <CheckCircleOutlined />, color: 'success', text: 'Completed' },
    failed: { icon: <CloseCircleOutlined />, color: 'error', text: 'Failed' },
    paused: { icon: <PauseCircleOutlined />, color: 'warning', text: 'Paused (Awaiting Approval)' }, // NEW text
  };
  
  const config = statusConfig[job.status] || { icon: <ClockCircleOutlined />, color: 'default', text: 'Queued' };

  return (
    <Tooltip title={job.error || job.result?.message || job.status_message}> {/* Include job.status_message */}
      <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
        <Tag icon={config.icon} color={config.color}>{config.text}</Tag>
        {(job.status === 'running' || job.status === 'paused') && ( // Show progress for paused as well
          <Progress percent={job.progress} size="small" status="active" showInfo={false} style={{ width: '100px', margin: 0 }} />
        )}
      </div>
    </Tooltip>
  );
};
export default JobStatusIndicator;
```

## File: src/components/PromptTemplateEditor.jsx
```javascript
// This is a new file. Create it with the following content:
import React, { useRef, useState, useEffect } from 'react';
import { Input, Button, Space, Tooltip, Typography, List, Divider, Row, Col, Card } from 'antd';
import { BulbOutlined, CopyOutlined } from '@ant-design/icons';

const { TextArea } = Input;
const { Text } = Typography;

const PLACEHOLDERS = [
  { name: "[TOPIC]", desc: "The main keyword or topic of the article." },
  { name: "[PRIMARY KEYWORD]", desc: "The exact target keyword for SEO." },
  { name: "[LSI/secondary keywords]", desc: "List of related keywords/entities to include." },
  { name: "[WORD_COUNT]", desc: "The target word count for the article." },
  { name: "[CTA_URL]", desc: "The call-to-action URL to promote." },
  { name: "[[IMAGE: <prompt>]]", desc: "Placeholder for in-article images (AI will fill <prompt>)." },
  // Add other placeholders as they become relevant
];

const PromptTemplateEditor = ({ value, onChange, disabled }) => {
  const textAreaRef = useRef(null);
  const [copied, setCopied] = useState(false);

  useEffect(() => {
    if (copied) {
      const timer = setTimeout(() => setCopied(false), 2000);
      return () => clearTimeout(timer);
    }
  }, [copied]);

  const handleInsertPlaceholder = (placeholder) => {
    const textarea = textAreaRef.current?.resizableTextArea?.textArea;
    if (textarea) {
      const start = textarea.selectionStart;
      const end = textarea.selectionEnd;
      const newValue = value.substring(0, start) + placeholder + value.substring(end, value.length);
      onChange(newValue);
      // Move cursor after inserted placeholder
      setTimeout(() => {
        textarea.selectionStart = textarea.selectionEnd = start + placeholder.length;
        textarea.focus();
      }, 0);
    }
  };

  return (
    <Row gutter={16}>
      <Col span={18}>
        <TextArea
          ref={textAreaRef}
          value={value}
          onChange={(e) => onChange(e.target.value)}
          rows={20}
          placeholder="Enter your custom AI prompt template here..."
          disabled={disabled}
          autoSize={{ minRows: 15, maxRows: 30 }}
        />
        <Space style={{ marginTop: '10px' }}>
          <Tooltip title="Copy entire prompt to clipboard">
            <Button icon={<CopyOutlined />} onClick={() => { handleInsertPlaceholder(value); setCopied(true); }}>
              {copied ? 'Copied!' : 'Copy Full Prompt'}
            </Button>
          </Tooltip>
        </Space>
      </Col>
      <Col span={6}>
        <Card title={<Space><BulbOutlined /> Available Placeholders</Space>} size="small">
          <List
            size="small"
            dataSource={PLACEHOLDERS}
            renderItem={item => (
              <List.Item
                actions={[
                  <Button
                    key="insert"
                    type="link"
                    size="small"
                    onClick={() => handleInsertPlaceholder(item.name)}
                    disabled={disabled}
                  >
                    Insert
                  </Button>
                ]}
              >
                <List.Item.Meta
                  title={<Text code>{item.name}</Text>}
                  description={<Text type="secondary" ellipsis={{tooltip: item.desc}}>{item.desc}</Text>}
                />
              </List.Item>
            )}
          />
          <Divider style={{ margin: '16px 0' }} />
          <Text type="secondary" style={{fontSize: '0.8em'}}>
            These placeholders will be dynamically replaced with data from your opportunity blueprint.
          </Text>
        </Card>
      </Col>
    </Row>
  );
};

export default PromptTemplateEditor;
```

## File: src/context/AuthContext.jsx
```javascript
// This is a new file. Create it with the following content:
import React, { createContext, useContext, useState, useEffect } from 'react';
import { login as apiLogin, logout as apiLogout } from '../services/authService';

export const AuthContext = createContext();

export const useAuth = () => useContext(AuthContext);

export const AuthProvider = ({ children }) => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [authToken, setAuthToken] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    try {
      const storedToken = localStorage.getItem('authToken');
      if (storedToken) {
        setAuthToken(storedToken);
        setIsAuthenticated(true);
      }
    } catch (error) {
      console.error("Failed to read authToken from localStorage:", error);
    } finally {
      setLoading(false);
    }
  }, []);

  const login = async (password) => {
    const response = await apiLogin(password);
    if (response && response.token) {
      try {
        localStorage.setItem('authToken', response.token);
        setAuthToken(response.token);
        setIsAuthenticated(true);
      } catch (error) {
        console.error("Failed to store authToken in localStorage:", error);
        // Even if localStorage fails, keep session in memory for current tab
        setAuthToken(response.token);
        setIsAuthenticated(true);
      }
    } else {
      throw new Error('No token received');
    }
  };

  const logout = async () => {
    try {
      await apiLogout();
      localStorage.removeItem('authToken');
      setAuthToken(null);
      setIsAuthenticated(false);
    } catch (error) {
      console.error("Logout failed:", error);
      // Even if API logout fails, clear local state
      localStorage.removeItem('authToken');
      setAuthToken(null);
      setIsAuthenticated(false);
      throw error; // Re-throw to allow component to show error
    }
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, authToken, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
};
```

## File: src/context/ClientContext.jsx
```javascript
import React, { createContext, useContext, useState, useEffect } from 'react';

export const ClientContext = createContext();

export const useClient = () => useContext(ClientContext);

export const ClientProvider = ({ children }) => {
    const [clientId, setClientIdState] = useState(() => { // Renamed local state setter
        try {
            const storedClientId = localStorage.getItem('clientId'); // Changed key from 'currentClientId'
            return storedClientId ? storedClientId : 'Lark_Main_Site'; // Use a consistent default if not found
        } catch (error) {
            console.error("Could not access localStorage for clientId:", error);
            return 'Lark_Main_Site';
        }
    });

    useEffect(() => {
        try {
            localStorage.setItem('clientId', clientId); // Changed key from 'currentClientId'
        } catch (error) {
            console.error("Could not write to localStorage for clientId:", error);
        }
    }, [clientId]);
      
    // New function to update clientId and persist to localStorage
    const updateClientId = (newClientId) => {
        setClientIdState(newClientId);
        try {
            localStorage.setItem('clientId', newClientId); // Changed key from 'currentClientId'
        } catch (error) {
            console.error("Could not write to localStorage for clientId:", error);
        }
    };

    const value = { clientId, setClientId: updateClientId }; // Provide the wrapped setter

    return (
        <ClientContext.Provider value={value}>
            {children}
        </ClientContext.Provider>
    );
};
```

## File: src/context/JobContext.jsx
```javascript
import React, { createContext, useState, useContext } from 'react';

const JobContext = createContext();

export const useJobs = () => useContext(JobContext);

export const JobProvider = ({ children }) => {
  const [activeJobs, setActiveJobs] = useState({});

  const startJob = (jobId, message) => {
    setActiveJobs(prev => ({ ...prev, [jobId]: { status: 'running', message } }));
  };

  const updateJob = (jobId, status, message) => {
    setActiveJobs(prev => {
      if (!prev[jobId]) return prev;
      return { ...prev, [jobId]: { ...prev[jobId], status, message } };
    });
  };

  const completeJob = (jobId) => {
    setTimeout(() => {
      setActiveJobs(prev => {
        const newJobs = { ...prev };
        delete newJobs[jobId];
        return newJobs;
      });
    }, 5000); // Remove after 5 seconds
  };

  return (
    <JobContext.Provider value={{ activeJobs, startJob, updateJob, completeJob }}>
      {children}
    </JobContext.Provider>
  );
};
```

## File: src/context/NotificationContext.jsx
```javascript
import React, { useContext } from 'react';
import { notification } from 'antd';

// Create a context to hold the notification logic
const NotificationContext = React.createContext();

// Custom hook to access the notification context
export const useNotifications = () => useContext(NotificationContext);

// Provider component that wraps your app
export const NotificationProvider = ({ children }) => {
  const showNotification = (type, message, description) => {
    notification[type]({
      message,
      description,
    });
  };

  return (
    <NotificationContext.Provider value={{ showNotification }}>
      {children}
    </NotificationContext.Provider>
  );
};
```

## File: src/hooks/useClient.js
```javascript
import { useContext } from 'react';
import { ClientContext } from '../context/ClientContext';

// Simple wrapper hook to ensure useClient is used within its Provider
export const useClient = () => {
    const context = useContext(ClientContext);
    if (context === undefined) {
        throw new Error('useClient must be used within a ClientProvider');
    }
    return context;
};
```

## File: src/hooks/useDebounce.js
```javascript
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
```

## File: src/pages/ActivityLog/ActivityLogPage.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Layout, Typography, Table, Space, Alert, Spin, Button, Tooltip } from 'antd';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { getAllJobs, cancelJob } from '../../services/orchestratorService';
import { formatDistanceToNow, format } from 'date-fns';
import { CloseCircleOutlined } from '@ant-design/icons';
import { useNotifications } from '../../context/NotificationContext';
import JobStatusIndicator from '../../components/JobStatusIndicator'; // NEW

const { Content } = Layout;
const { Title, Text } = Typography;



const ActivityLogPage = () => {
  const queryClient = useQueryClient();
  const { showNotification } = useNotifications();

  const { data: jobs = [], isLoading, isError, error } = useQuery(
    'allJobs',
    getAllJobs,
    {
      refetchInterval: (data) =>
        data?.some((job) => job.status === 'running' || job.status === 'pending') ? 3000 : false, // Refetch every 3s if any job is running
    }
  );

  const { mutate: cancelJobMutation, isLoading: isCancelling } = useMutation(
    (jobId) => cancelJob(jobId),
    {
      onSuccess: () => {
        showNotification('info', 'Job Cancellation', 'Job cancellation request sent.');
        queryClient.invalidateQueries('allJobs'); // Refetch to show updated status
      },
      onError: (err) => {
        showNotification('error', 'Cancellation Failed', err.message || 'An error occurred during cancellation.');
      },
    }
  );

  const columns = [
    {
      title: 'Job ID',
      dataIndex: 'id',
      key: 'id',
      render: (text) => <Text code>{text.substring(0, 8)}...</Text>,
    },
    {
      title: 'Type',
      dataIndex: 'function_name',
      key: 'function_name',
      render: (text) => text ? text.replace(/_background$/, '').replace(/_/g, ' ').replace('run ', '').replace('run', '').trim().toUpperCase() : 'N/A',
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (_, record) => <JobStatusIndicator jobId={record.id} />, // Use the new component
    },
    {
      title: 'Current Step',
      dataIndex: 'result',
      key: 'step',
      render: (result) => result?.step || 'N/A',
    },
    {
      title: 'Started',
      dataIndex: 'started_at',
      key: 'started_at',
      render: (timestamp) => timestamp ? formatDistanceToNow(new Date(timestamp * 1000), { addSuffix: true }) : 'N/A',
    },
    {
      title: 'Finished',
      dataIndex: 'finished_at',
      key: 'finished_at',
      render: (timestamp) => timestamp ? format(new Date(timestamp * 1000), 'MMM d, hh:mm a') : 'N/A',
    },
    {
      title: 'Error',
      dataIndex: 'error',
      key: 'error',
      render: (errorMsg) => errorMsg ? (
        <Tooltip title={errorMsg}>
          <Text type="danger" ellipsis>{errorMsg}</Text>
        </Tooltip>
      ) : 'N/A',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record) => (
        <Space size="small">
          {record.status === 'running' && (
            <Tooltip title="Cancel Job">
              <Button 
                danger 
                icon={<CloseCircleOutlined />} 
                size="small" 
                onClick={() => cancelJobMutation(record.id)} 
                loading={isCancelling} 
              />
            </Tooltip>
          )}
        </Space>
      ),
    },
  ];

  if (isLoading) {
    return <Spin tip="Loading activity log..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (isError) {
    return <Alert message="Error" description={error?.message || "Failed to load activity log. Please try again."} type="error" showIcon />;
  }

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Title level={2}>Activity Log</Title>
        <Table
          columns={columns}
          dataSource={jobs}
          rowKey="id"
          pagination={{ pageSize: 10 }}
          scroll={{ x: 1000 }}
        />
      </Content>
    </Layout>
  );
};

export default ActivityLogPage;
```

## File: src/pages/Auth/LoginPage.jsx
```javascript
// This is a new file. Create it with the following content:
import React, { useState } from 'react';
import { Form, Input, Button, Card, Typography, Alert, Space } from 'antd';
import { LockOutlined } from '@ant-design/icons';
import { useAuth } from '../../context/AuthContext';
import { useNavigate } from 'react-router-dom';

const { Title } = Typography;

const LoginPage = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { login } = useAuth();
  const navigate = useNavigate();

  const onFinish = async (values) => {
    setLoading(true);
    setError(null);
    try {
      await login(values.password); // Only password is required for dummy login
      navigate('/dashboard'); // Redirect to the main dashboard on success
    } catch (err) {
      setError(err.message || 'Login failed. Please check your password.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Space
      direction="vertical"
      align="center"
      style={{
        width: '100%',
        minHeight: '100vh',
        justifyContent: 'center',
        background: '#f0f2f5',
      }}
    >
      <Card style={{ width: 350, textAlign: 'center' }}>
        <Title level={3}>Content AI Login</Title>
        {error && (
          <Alert message="Authentication Failed" description={error} type="error" showIcon style={{ marginBottom: 20 }} />
        )}
        <Form
          name="login"
          initialValues={{ remember: true }}
          onFinish={onFinish}
        >
          <Form.Item
            name="password"
            rules={[{ required: true, message: 'Please enter your password!' }]}
          >
            <Input.Password prefix={<LockOutlined />} placeholder="Password" />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" loading={loading} block>
              Log in
            </Button>
          </Form.Item>
        </Form>
      </Card>
    </Space>
  );
};

export default LoginPage;
```

## File: src/pages/BlogPage/BlogPage.css
```css
.blog-layout {
    background: #fff;
    padding: 40px 0;
}

.blog-content {
    max-width: 800px;
    margin: 0 auto;
    padding: 0 24px;
}

.blog-post-container {
    border-radius: 8px;
    overflow: hidden;
}

.blog-title {
    font-size: 3em;
    font-weight: 700;
    line-height: 1.2;
    margin-bottom: 24px;
    color: #1a1a1a;
}

.author-info {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 32px;
}

.featured-image {
    width: 100%;
    height: auto;
    border-radius: 8px;
    margin-bottom: 32px;
    object-fit: cover;
}

.blog-body {
    font-size: 1.1em;
    line-height: 1.8;
    color: #333;
}

.blog-body h1, .blog-body h2, .blog-body h3 {
    font-weight: 600;
    margin-top: 2em;
    margin-bottom: 1em;
    color: #1a1a1a;
}

.blog-body p {
    margin-bottom: 1.5em;
}

.blog-body a {
    color: #1890ff;
    text-decoration: none;
}

.blog-body a:hover {
    text-decoration: underline;
}

.blog-body ul, .blog-body ol {
    padding-left: 2em;
    margin-bottom: 1.5em;
}

.blog-body blockquote {
    border-left: 4px solid #e8e8e8;
    padding-left: 1em;
    margin: 2em 0;
    color: #666;
    font-style: italic;
}

.loading-container {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
}

/* Styles to make the Quill Editor body match the blog body for a WYSIWYG experience */
.blog-body .ql-editor {
    font-size: 1.1em;
    line-height: 1.8;
    color: #333;
    min-height: 600px;
}

.blog-body .ql-editor h1, .blog-body .ql-editor h2, .blog-body .ql-editor h3 {
    font-weight: 600;
    margin-top: 2em;
    margin-bottom: 1em;
    color: #1a1a1a;
}

.blog-body .ql-editor p {
    margin-bottom: 1.5em;
}

.blog-body .ql-editor blockquote {
    border-left: 4px solid #e8e8e8;
    padding-left: 1em;
    margin: 2em 0;
    color: #666;
    font-style: italic;
}
```

## File: src/pages/BlogPage/BlogPage.jsx
```javascript
import React from 'react';
import { useParams } from 'react-router-dom';
import { useQuery } from 'react-query';
import { getOpportunityById } from '../../services/opportunitiesService';
import { Layout, Typography, Spin, Alert, Result, Button, Avatar, Space } from 'antd';
import { UserOutlined } from '@ant-design/icons';
import { Link } from 'react-router-dom';
import './BlogPage.css';

const { Content } = Layout;
const { Title, Text } = Typography;

const BlogPage = () => {
  const { opportunityId } = useParams();
  const { data: opportunity, isLoading, isError, error } = useQuery(
    ['opportunity', opportunityId],
    () => getOpportunityById(opportunityId)
  );

  if (isLoading) {
    return (
      <div className="loading-container">
        <Spin size="large" tip="Loading article..." />
      </div>
    );
  }

  if (isError) {
    return <Alert message="Error" description={error.message} type="error" showIcon />;
  }

  const {
    keyword,
    final_package_json,
    author_name = 'AI Assistant',
    publication_date = new Date().toLocaleDateString(),
  } = opportunity || {};

  if (!final_package_json || !final_package_json.article_html_final) {
    return (
      <Result
        status="404"
        title="Content Not Found"
        subTitle="The final content package for this opportunity has not been generated yet."
        extra={<Button type="primary"><Link to={`/opportunities/${opportunityId}`}>Go Back</Link></Button>}
      />
    );
  }

  return (
    <Layout className="blog-layout">
      <Content className="blog-content">
        <div className="blog-post-container">
          <Title level={1} className="blog-title">{final_package_json.meta_title || keyword}</Title>
          <div className="author-info">
            <Avatar icon={<UserOutlined />} />
            <Space direction="vertical" size={0}>
              <Text strong>{author_name}</Text>
              <Text type="secondary">Published on {publication_date}</Text>
            </Space>
          </div>

          {final_package_json.featured_image_relative_path && (
            <img src={final_package_json.featured_image_relative_path} alt={keyword} className="featured-image" />
          )}

          <div
            className="blog-body"
            dangerouslySetInnerHTML={{ __html: final_package_json.article_html_final }}
          />
        </div>
      </Content>
    </Layout>
  );
};

export default BlogPage;
```

## File: src/pages/ClientDashboard/AddNewClientModal.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Modal, Form, Input } from 'antd';

const AddNewClientModal = ({ open, onCancel, onAddClient, loading }) => {
  const [form] = Form.useForm();

  const handleOk = () => {
    form.validateFields()
      .then(values => {
        onAddClient(values);
        form.resetFields();
      })
      .catch(info => {
        console.log('Validate Failed:', info);
      });
  };

  return (
    <Modal
      title="Add New Client"
      open={open}
      onOk={handleOk}
      onCancel={onCancel}
      confirmLoading={loading}
      okText="Add Client"
    >
      <Form
        form={form}
        layout="vertical"
        name="add_client_form"
      >
        <Form.Item
          name="client_name"
          label="Client Name"
          rules={[{ required: true, message: 'Please enter the client\'s name!' }]}
        >
          <Input autoFocus />
        </Form.Item>
        <Form.Item
          name="client_id"
          label="Client ID"
          rules={[{ required: true, message: 'Please enter a unique client ID!' }]}
          extra="This should be a unique identifier for the client (e.g., my_company_name)."
        >
          <Input />
        </Form.Item>
      </Form>
    </Modal>
  );
};

export default AddNewClientModal;
```

## File: src/pages/ClientDashboard/ClientDashboardPage.jsx
```javascript
// This is a new file. Create it with the following content:
import React, { useState } from 'react';
import { Layout, Typography, Spin, Alert, Card, Row, Col, Statistic, Button, Space } from 'antd';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { getClients, getDashboardStats, addClient } from '../../services/clientService';
import { useClient } from '../../hooks/useClient';
import { useNotifications } from '../../context/NotificationContext';
import AddNewClientModal from './AddNewClientModal';
import { useNavigate } from 'react-router-dom'; // NEW

const { Content } = Layout;
const { Title } = Typography;

const ClientCard = ({ client, onSelectClient, isActive }) => {
  const { data: stats, isLoading: isLoadingStats, isError: isErrorStats } = useQuery(
    ['dashboardStats', client.client_id],
    () => getDashboardStats(client.client_id),
    {
      enabled: !!client.client_id,
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    }
  );

  return (
    <Card
      title={<Title level={5} style={{ margin: 0 }}>{client.client_name}</Title>}
      extra={
        <Button
          type={isActive ? "primary" : "default"}
          onClick={() => onSelectClient(client.client_id)}
          disabled={isActive}
        >
          {isActive ? 'Current Client' : 'Select'}
        </Button>
      }
      style={{ marginBottom: '16px' }}
      loading={isLoadingStats}
    >
      <Row gutter={16}>
        <Col span={8}>
          <Statistic title="Opportunities" value={stats?.status_counts?.all || 0} />
        </Col>
        <Col span={8}>
          <Statistic title="Qualified" value={stats?.status_counts?.validated || 0} />
        </Col>
        <Col span={8}>
          <Statistic title="Generated" value={stats?.status_counts?.generated || 0} />
        </Col>
      </Row>
      {isErrorStats && (
        <Alert
          message="Error loading stats"
          description={isErrorStats?.message || 'Failed to load dashboard statistics.'}
          type="error"
          style={{ marginTop: '16px' }}
        />
      )}
    </Card>
  );
};

const ClientDashboardPage = () => {
  const { clientId, setClientId } = useClient();
  const { showNotification } = useNotifications();
  const queryClient = useQueryClient();
  const navigate = useNavigate(); // NEW
  const [isModalVisible, setIsModalVisible] = useState(false);

  const { data: clients = [], isLoading, isError, error } = useQuery(
    'clients',
    getClients,
  );

  const { mutate: addClientMutation, isLoading: isAddingClient } = useMutation(
    (newClient) => addClient(newClient),
    {
      onSuccess: () => {
        showNotification('success', 'Client Added', 'New client has been successfully added.');
        queryClient.invalidateQueries('clients'); // Invalidate to refetch client list
        setIsModalVisible(false);
      },
      onError: (err) => {
        showNotification('error', 'Failed to Add Client', err.message || 'An error occurred while adding the client.');
      },
    }
  );

  const handleSelectClient = (selectedClientId) => {
    setClientId(selectedClientId);
    navigate('/dashboard'); // Navigate to the new dashboard page after selecting
  };

  if (isLoading) {
    return <Spin tip="Loading clients..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (isError) {
    return <Alert message="Error" description={error?.message || "Failed to load clients. Please try again."} type="error" showIcon />;
  }

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Title level={2}>Client Dashboard</Title>
        <Space style={{ marginBottom: '16px' }}>
          <Button type="primary" onClick={() => setIsModalVisible(true)}>Add New Client</Button>
        </Space>

        <Row gutter={[16, 16]}>
          {clients.map(client => (
            <Col xs={24} sm={12} md={8} lg={6} key={client.client_id}>
              <ClientCard 
                client={client} 
                onSelectClient={handleSelectClient} 
                isActive={client.client_id === clientId} 
              />
            </Col>
          ))}
        </Row>
      </Content>
      <AddNewClientModal
        open={isModalVisible}
        onCancel={() => setIsModalVisible(false)}
        onAddClient={addClientMutation}
        loading={isAddingClient}
      />
    </Layout>
  );
};

export default ClientDashboardPage;
```

## File: src/pages/ClientSettings/ClientSettingsPage.jsx
```javascript
// my-content-app/src/pages/ClientSettings/ClientSettingsPage.jsx
// NEW FILE
import React from 'react';
import { Layout, Typography, Form, Input, Button, Spin, Alert } from 'antd';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { getClientSettings, updateClientSettings } from '../../services/clientSettingsService';
import { useNotifications } from '../../context/NotificationContext';

const { Content } = Layout;
const { Title } = Typography;
const { TextArea } = Input;

const ClientSettingsPage = ({ clientId = 'default' }) => {
  const [form] = Form.useForm();
  const queryClient = useQueryClient();
  const { showNotification } = useNotifications();

  const { data: settings, isLoading, isError, error } = useQuery(
    ['clientSettings', clientId],
    () => getClientSettings(clientId),
    {
      enabled: !!clientId,
      onSuccess: (data) => {
        form.setFieldsValue(data);
      }
    }
  );

  const { mutate: updateSettingsMutation, isLoading: isUpdating } = useMutation(
    (newSettings) => updateClientSettings(clientId, newSettings),
    {
      onSuccess: () => {
        showNotification('success', 'Settings Updated', 'Client settings have been saved successfully.');
        queryClient.invalidateQueries(['clientSettings', clientId]);
      },
      onError: (err) => {
        showNotification('error', 'Update Failed', err.message || 'An error occurred while saving settings.');
      }
    }
  );

  const onFinish = (values) => {
    updateSettingsMutation(values);
  };

  if (isLoading) return <Spin tip="Loading settings..." />;
  if (isError) return <Alert message="Error" description={error.message} type="error" showIcon />;

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Title level={2}>Client AI & Content Settings</Title>
        <Form
          form={form}
          layout="vertical"
          onFinish={onFinish}
          initialValues={settings}
        >
          <Form.Item
            name="brand_tone"
            label="Brand Tone & Voice"
            tooltip="Define the desired tone for the AI-generated content (e.g., professional, witty, conversational)."
          >
            <TextArea rows={4} placeholder="e.g., Professional and authoritative, but accessible to a general audience." />
          </Form.Item>

          <Form.Item
            name="target_audience"
            label="Target Audience"
            tooltip="Describe the primary audience for the content."
          >
            <TextArea rows={4} placeholder="e.g., Marketing managers at mid-sized tech companies." />
          </Form.Item>

          <Form.Item
            name="terms_to_avoid"
            label="Terms to Avoid"
            tooltip="List any specific words or phrases the AI should not use. Separate with commas."
          >
            <Input placeholder="e.g., synergy, disruptive, unicorn" />
          </Form.Item>

          <Form.Item
            name="client_knowledge_base"
            label="Client Knowledge Base"
            tooltip="Provide key facts, product names, and unique selling propositions for your brand. This will be injected into every AI content generation prompt."
          >
            <TextArea rows={6} placeholder="e.g., Our flagship product is 'ProfitPilot', an AI-powered SEO tool designed for small businesses to automate keyword research and content generation. We focus on ROI and actionable insights, not just vanity metrics." />
          </Form.Item>

          <Form.Item>
            <Button type="primary" htmlType="submit" loading={isUpdating}>
              Save Settings
            </Button>
          </Form.Item>
        </Form>
      </Content>
    </Layout>
  );
};

export default ClientSettingsPage;
```

## File: src/pages/Dashboard/DashboardPage.jsx
```javascript
import React from 'react';
import { useQuery } from 'react-query';
import { Layout, Typography, Spin, Alert, Row, Col, Card, Statistic, Table, Tag } from 'antd';
import { 
  FileTextOutlined, 
  CheckCircleOutlined, 
  DollarCircleOutlined, 
  ExperimentOutlined,
  ClockCircleOutlined,
  WarningOutlined,
  ArrowRightOutlined,
  ReadOutlined
} from '@ant-design/icons';
import { useClient } from '../../hooks/useClient';
import { getDashboardData } from '../../services/clientService';
import { format } from 'date-fns';
import { useNavigate } from 'react-router-dom';
import FunnelChart from '../DiscoveryPage/components/FunnelChart';

const { Content } = Layout;
const { Title, Text, Link } = Typography;

const KpiCard = ({ icon, title, value, prefix, precision = 0 }) => (
  <Card>
    <Statistic 
      title={title} 
      value={value} 
      precision={precision} 
      prefix={icon ? React.createElement(icon, { style: { marginRight: 8 } }) : prefix} 
    />
  </Card>
);

const DashboardPage = () => {
  const { clientId } = useClient();
  const navigate = useNavigate();

  const { data, isLoading, isError, error } = useQuery(
    ['dashboardData', clientId],
    () => getDashboardData(clientId),
    {
      enabled: !!clientId,
    }
  );

  if (isLoading) {
    return <Spin tip="Loading dashboard..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (isError) {
    return <Alert message="Error" description={error.message} type="error" showIcon />;
  }

  const { kpis, funnelData, actionItems, recent_items } = data;

  const actionColumns = [
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      key: 'keyword',
      render: (text, record) => <Link onClick={() => navigate(`/opportunities/${record.id}`)}>{text}</Link>,
    },
    {
      title: 'Score',
      dataIndex: 'strategic_score',
      key: 'strategic_score',
      render: (score) => (
        <Tag color="blue">
          {typeof score === 'number' ? score.toFixed(1) : 'N/A'}
        </Tag>
      ),
    },
    {
      title: 'Updated',
      dataIndex: 'updated_at',
      key: 'updated_at',
      render: (ts) => ts ? format(new Date(ts), 'yyyy-MM-dd') : 'N/A',
    },
    {
      title: 'Action',
      key: 'action',
      render: (_, record) => <Link onClick={() => navigate(`/opportunities/${record.id}`)}>Review <ArrowRightOutlined /></Link>,
    },
  ];

  const failedColumns = [
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      key: 'keyword',
      render: (text, record) => <Link onClick={() => navigate(`/opportunities/${record.id}`)}>{text}</Link>,
    },
    {
      title: 'Error',
      dataIndex: 'error_message',
      key: 'error_message',
      render: (msg) => <Text type="danger" ellipsis={{ tooltip: msg }}>{msg || 'No details'}</Text>,
    },
    {
      title: 'Action',
      key: 'action',
      render: (_, record) => <Link onClick={() => navigate(`/opportunities/${record.id}`)}>Details <ArrowRightOutlined /></Link>,
    },
  ];
  
  const recentActivityColumns = [
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      key: 'keyword',
      render: (text, record) => <Link onClick={() => navigate(`/opportunities/${record.id}`)}>{text}</Link>,
    },
    {
      title: 'Generated On',
      dataIndex: 'date_processed',
      key: 'date_processed',
      render: (ts) => ts ? format(new Date(ts), 'yyyy-MM-dd HH:mm') : 'N/A',
    },
    {
        title: 'Action',
        key: 'action',
        render: (_, record) => <Link onClick={() => navigate(`/opportunities/${record.id}?tab=Article`)}>View Article <ReadOutlined /></Link>,
    },
  ];

  // Safely extract funnel data
  const getFunnelCount = (stage) => funnelData?.find(d => d.stage === stage)?.count || 0;

  return (
    <Layout>
      <Content style={{ padding: '24px' }}>
        <Title level={2}>Dashboard for {clientId}</Title>
        
        <Row gutter={[24, 24]} style={{ marginBottom: '24px' }}>
          <Col xs={24} sm={12} md={6}><KpiCard icon={FileTextOutlined} title="Total Opportunities" value={kpis.totalOpportunities} /></Col>
          <Col xs={24} sm={12} md={6}><KpiCard icon={CheckCircleOutlined} title="Content Generated" value={kpis.contentGenerated} /></Col>
          <Col xs={24} sm={12} md={6}><KpiCard icon={DollarCircleOutlined} title="Est. Monthly Traffic Value" value={kpis.totalTrafficValue} prefix="$" precision={2} /></Col>
          <Col xs={24} sm={12} md={6}><KpiCard icon={ExperimentOutlined} title="Total API Cost" value={kpis.totalApiCost} prefix="$" precision={2} /></Col>
        </Row>

        <Row gutter={[24, 24]}>
          {/* Left Column */}
          <Col xs={24} lg={16}>
            <div style={{ display: 'flex', flexDirection: 'column', gap: '24px' }}>
              {actionItems?.awaitingApproval?.length > 0 && (
                <Card title={<><ClockCircleOutlined style={{marginRight: 8}} /> Awaiting Your Approval</>}>
                  <Table
                    dataSource={actionItems.awaitingApproval}
                    columns={actionColumns}
                    rowKey="id"
                    pagination={{ pageSize: 5 }}
                    size="small"
                  />
                </Card>
              )}
              {actionItems?.failed?.length > 0 && (
                <Card title={<><WarningOutlined style={{marginRight: 8}} /> Failed Workflows</>}>
                  <Table
                    dataSource={actionItems.failed}
                    columns={failedColumns}
                    rowKey="id"
                    pagination={{ pageSize: 5 }}
                    size="small"
                  />
                </Card>
              )}
            </div>
          </Col>

          {/* Right Column */}
          <Col xs={24} lg={8}>
             <div style={{ display: 'flex', flexDirection: 'column', gap: '24px' }}>
                <Card title="Recent Activity">
                    <Table
                        dataSource={recent_items}
                        columns={recentActivityColumns}
                        rowKey="id"
                        pagination={{ pageSize: 10 }}
                        size="small"
                        locale={{ emptyText: 'No recent activity' }}
                    />
                </Card>
                <Card title="Content Pipeline Funnel">
                  <FunnelChart 
                    totalRaw={getFunnelCount('Total')}
                    unique={getFunnelCount('Validated')}
                    qualified={getFunnelCount('Analyzed')}
                    disqualified={getFunnelCount('Disqualified')}
                    addedToDB={getFunnelCount('Generated')}
                  />
                </Card>
             </div>
          </Col>
        </Row>
      </Content>
    </Layout>
  );
};

export default DashboardPage;
```

## File: src/pages/DiscoveryPage/components/DiscoveryForm.jsx
```javascript
import React from 'react';
import { Input, Button, Typography, Form, Row, Col, InputNumber, Select, Switch, Modal } from 'antd';
import { RocketOutlined } from '@ant-design/icons';
import { useDiscoveryFilters } from '../hooks/useDiscoveryFilters';

const { Title } = Typography;
const { Option } = Select;

const DiscoveryForm = ({ isSubmitting, onSubmit }) => {
  const [form] = Form.useForm();
  useDiscoveryFilters();

      const onFinish = (values) => {
        const currentFilters = form.getFieldValue('filters'); // Assuming 'filters' is the form item holding the filter array
        if (currentFilters && currentFilters.length > 8) {
            Modal.error({
                title: 'Too Many Filters',
                content: 'You can specify a maximum of 8 filter conditions. Please remove some filters.',
            });
            return;
        }
        const { keyword, limit, search_volume_value, difficulty_value, competition_level, search_intent, include_clickstream_data, closely_variants, ignore_synonyms, exact_match } = values;

// ADDITION: Read discovery mode and max pages from form values
const discovery_modes = form.getFieldValue('discovery_modes') || ['ideas'];
const discovery_max_pages = form.getFieldValue('discovery_max_pages') || 1;

        // ... (rest of filtering logic) ...
        const filters = [];
        const filterPathPrefix = 'keyword_data.'; // Defaulting to a common prefix, backend will handle specifics
        if (search_volume_value !== undefined && search_volume_value !== null) {
          filters.push({ field: `${filterPathPrefix}keyword_info.search_volume`, operator: '>', value: search_volume_value });
        }
        if (difficulty_value !== undefined && difficulty_value !== null) {
          filters.push({ field: `${filterPathPrefix}keyword_properties.keyword_difficulty`, operator: '<', value: difficulty_value });
        }
        if (competition_level && competition_level.length > 0) {
          filters.push({ field: `${filterPathPrefix}keyword_info.competition_level`, operator: 'in', value: competition_level });
        }
        if (search_intent && search_intent.length > 0) {
          filters.push({ field: `${filterPathPrefix}search_intent_info.main_intent`, operator: 'in', value: search_intent });
        }

        const runData = {
          seed_keywords: [keyword],
          limit: limit,
          filters: filters.length > 0 ? filters : null,
          include_clickstream_data,
          closely_variants,
          ignore_synonyms,
          exact_match,
// ADD these fields to runData:
discovery_modes,
discovery_max_pages,
        };
        
        onSubmit({ runData });
      };

  

      return (

  

        <Form form={form} layout="vertical" onFinish={onFinish} initialValues={{

  

          limit: 1000,

  

          search_volume_value: 500,

  

          difficulty_value: 20,

  

          competition_level: ['LOW'],

  

          search_intent: ['informational'],

  

        }}>

  

          <Title level={4}>1. Enter a Seed Keyword</Title>

  

          <Form.Item name="keyword" rules={[{ required: true, message: 'Please enter a seed keyword.' }]}>

  

            <Input placeholder="e.g., content marketing" />

  

          </Form.Item>

  

          

  

          <Title level={4}>2. Add Filters (Optional)</Title>

  

          <Row gutter={16}>

  

            <Col span={12}>

  

              <Form.Item name="limit" label="Limit (Number of keywords to find)">

  

                <InputNumber style={{ width: '100%' }} placeholder="e.g., 1000" />

  

              </Form.Item>

  

            </Col>

  

            <Col span={12}>

  

              <Form.Item name="search_volume_value" label="Monthly Search Volume (Greater than)">

  

                <InputNumber style={{ width: '100%' }} placeholder="e.g., 500" />

  

              </Form.Item>

  

            </Col>

  

            <Col span={12}>

  

              <Form.Item name="difficulty_value" label="SEO Difficulty (Less than)">

  

                <InputNumber style={{ width: '100%' }} placeholder="e.g., 20" min={0} max={100} />

  

              </Form.Item>

  

            </Col>

  

            <Col span={12}>

  

              <Form.Item name="competition_level" label="Competition Level">

  

                <Select mode="multiple" placeholder="Any" allowClear>

  

                  <Option value="LOW">Low</Option>

  

                  <Option value="MEDIUM">Medium</Option>

  

                  <Option value="HIGH">High</Option>

  

                </Select>

  

              </Form.Item>

  

            </Col>

  

            <Col span={12}>

  

              <Form.Item name="search_intent" label="Search Intent">

  

                <Select mode="multiple" placeholder="Any" allowClear>

  

                  <Option value="informational">Informational</Option>

  

                  <Option value="commercial">Commercial</Option>

  

                  <Option value="transactional">Transactional</Option>

  

                  <Option value="navigational">Navigational</Option>

  

                </Select>

  

              </Form.Item>

  

            </Col>

  

          </Row>

          <Row gutter={16}>
            <Col span={24}>
              <Form.Item name="include_clickstream_data" label="Include Clickstream Demographics" valuePropName="checked" tooltip="Provides audience demographic data but doubles the API cost of the discovery run.">
                <Switch />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item name="closely_variants" label="Use Phrase Match" valuePropName="checked" tooltip="Limits results to keywords that are close variants of the seed keyword (more targeted).">
                <Switch />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item name="exact_match" label="Use Exact Match" valuePropName="checked" tooltip="Returns only keywords that exactly match the seed keyword's phrasing.">
                <Switch />
              </Form.Item>
            </Col>
            <Col span={12}>
              <Form.Item name="ignore_synonyms" label="Ignore Synonyms" valuePropName="checked" tooltip="Returns only core keywords, excluding highly similar variations.">
                <Switch />
              </Form.Item>
            </Col>
          </Row>

      <Row justify="end" align="middle" style={{ marginTop: '24px' }}>
        <Col>
          <Button type="primary" htmlType="submit" icon={<RocketOutlined />} loading={isSubmitting} size="large">
            Find Opportunities
          </Button>
        </Col>
      </Row>
    </Form>
  );
};

export default DiscoveryForm;
```

## File: src/pages/DiscoveryPage/components/DiscoveryHistory.jsx
```javascript
import React, { useState, useMemo } from 'react';
import { Table, Tag, Tooltip, Button, Modal, Progress, Empty, Typography, Input, Row, Col, DatePicker, Alert } from 'antd';
import { ReloadOutlined, ProfileOutlined, ClockCircleOutlined, CheckCircleOutlined, CloseCircleOutlined, LoadingOutlined, EyeOutlined } from '@ant-design/icons';
import { useNavigate } from 'react-router-dom';
import { formatDistanceToNow } from 'date-fns';
import RunDetailsModal from './RunDetailsModal';
import DiscoveryStatsBreakdown from './DiscoveryStatsBreakdown'; // NEW: For expandable row

const { Title, Text } = Typography;
const { Search } = Input;
const { RangePicker } = DatePicker;

const STATUS_CONFIG = {
  running: { color: 'processing', text: 'Running', icon: <LoadingOutlined spin /> },
  completed: { color: 'success', text: 'Completed', icon: <CheckCircleOutlined /> },
  failed: { color: 'error', text: 'Failed', icon: <CloseCircleOutlined /> },
  pending: { color: 'default', text: 'Pending', icon: <ClockCircleOutlined /> },
};

const DiscoveryHistory = ({ runs, totalRuns, page, setPage, isLoading, onRerun, isRerunning }) => {
  const navigate = useNavigate();
  const [filterText, setFilterText] = useState('');
  const [dateRange, setDateRange] = useState(null);
  const [errorModal, setErrorModal] = useState({ open: false, content: '' });
  const [detailsModal, setDetailsModal] = useState({ open: false, run: null });

  const handleShowError = (errorMsg) => {
    setErrorModal({ open: true, content: errorMsg || 'No error details provided.' });
  };

  const handleShowDetails = (run) => {
    setDetailsModal({ open: true, run: run });
  };

  const filteredRuns = useMemo(() => {
    let filtered = runs;

    if (filterText) {
      const lowerCaseFilter = filterText.toLowerCase();
      filtered = filtered.filter(run => 
        run.parameters?.seed_keywords?.some(kw => kw.toLowerCase().includes(lowerCaseFilter)) || 
        run.status.toLowerCase().includes(lowerCaseFilter)
      );
    }

    if (dateRange) {
      const [start, end] = dateRange;
      filtered = filtered.filter(run => {
        const runDate = new Date(run.start_time);
        return runDate >= start && runDate <= end;
      });
    }

    return filtered;
  }, [runs, filterText, dateRange]);

  const expandedRowRender = (record) => {
    if (!record.results_summary) {
      return <Text type="secondary">No detailed summary available for this run.</Text>;
    }
    return <DiscoveryStatsBreakdown summary={record.results_summary} runId={record.id} />;
  };

  const columns = [
    {
      title: 'Start Time',
      dataIndex: 'start_time',
      key: 'start_time',
      render: (text) => text ? `${formatDistanceToNow(new Date(text))} ago` : 'N/A',
      sorter: (a, b) => new Date(a.start_time) - new Date(b.start_time),
      defaultSortOrder: 'descend',
    },
    {
      title: 'Status',
      dataIndex: 'status',
      key: 'status',
      render: (status, record) => {
        const config = STATUS_CONFIG[status] || STATUS_CONFIG.pending;
        const progress = record.results_summary?.progress || (status === 'running' ? record.progress || 0 : 0);
        return (
          <div style={{ display: 'flex', alignItems: 'center', flexDirection: 'column' }}>
            <Tag icon={config.icon} color={config.color} onClick={() => status === 'failed' && handleShowError(record.error_message)} style={{ cursor: status === 'failed' ? 'pointer' : 'default', marginBottom: 4 }}>
              {config.text}
            </Tag>
            {status === 'running' && <Progress percent={progress} size="small" status="active" showInfo={false} style={{ width: 100 }} />}
          </div>
        );
      },
      sorter: (a, b) => a.status.localeCompare(b.status),
    },
    {
      title: 'Seed Keywords',
      dataIndex: 'parameters',
      key: 'seed_keywords',
      responsive: ['md'],
      render: (params) => {
        const keywords = params?.seed_keywords || [];
        if (keywords.length === 0) return <Text type="secondary">N/A</Text>;
        const displayedKeywords = keywords.slice(0, 3);
        const remainingCount = keywords.length - displayedKeywords.length;
        return (
          <>
            {displayedKeywords.map(kw => <Tag key={kw}>{kw}</Tag>)}
            {remainingCount > 0 && <Tooltip title={keywords.slice(3).join(', ')}><Tag>+{remainingCount} more</Tag></Tooltip>}
          </>
        );
      },
    },
    {
      title: 'Discovery Mode',
      dataIndex: 'parameters',
      key: 'discovery_mode',
      responsive: ['lg'],
      render: (params) => {
        const modes = params?.discovery_modes || ['ideas'];
        const filters = params?.filters;
        const orderBy = params?.order_by;
        const tooltipContent = (
          <pre style={{ maxWidth: 500, whiteSpace: 'pre-wrap' }}>
            {JSON.stringify({ filters, order_by: orderBy }, null, 2)}
          </pre>
        );
        return (
          <Tooltip title={tooltipContent}>
            {modes.map(mode => <Tag key={mode}>{mode.replace('_', ' ').toUpperCase()}</Tag>)}
          </Tooltip>
        );
      },
    },
    {
      title: 'Actions',
      key: 'actions',
      align: 'right',
      fixed: 'right',
      render: (_, record) => (
        <div style={{ display: 'flex', gap: '8px', justifyContent: 'flex-end' }}>
          <Tooltip title="Re-run this discovery with the same settings">
            <Button icon={<ReloadOutlined />} onClick={() => onRerun(record.id)} disabled={isRerunning} />
          </Tooltip>
          {record.status === 'completed' && (
            <>
              <Tooltip title="View Run Details">
                <Button icon={<EyeOutlined />} onClick={() => handleShowDetails(record)} />
              </Tooltip>
              <Tooltip title="View Keywords">
                <Button type="primary" icon={<ProfileOutlined />} onClick={() => navigate(`/discovery-run/${record.id}`)} />
              </Tooltip>
            </>
          )}
        </div>
      ),
    },
  ];

  return (
    <div style={{ marginTop: '32px' }}>
        <Row justify="space-between" align="middle" style={{ marginBottom: '16px' }} gutter={[16, 16]}>
            <Col><Title level={3} style={{margin: 0}}>Discovery History</Title></Col>
            <Col flex="auto" style={{textAlign: 'right'}}>
              <Search 
                placeholder="Filter by keyword or status..." 
                allowClear 
                value={filterText} 
                onChange={e => setFilterText(e.target.value)} 
                style={{ width: 250, marginRight: '8px' }} 
              />
              <RangePicker onChange={(dates) => setDateRange(dates)} />
            </Col>
        </Row>
      <Table
        loading={isLoading}
        columns={columns}
        dataSource={filteredRuns}
        rowKey="id"
        scroll={{ x: 800 }}
        locale={{ emptyText: <Empty description="No discovery runs found. Start one above to see your history." /> }}
        pagination={{
          current: page,
          pageSize: 10,
          total: totalRuns,
          onChange: setPage,
        }}
        expandable={{ expandedRowRender }} // NEW: Enable expandable rows
      />
      <Modal title="Run Failed" open={errorModal.open} onOk={() => setErrorModal({ open: false, content: '' })} onCancel={() => setErrorModal({ open: false, content: '' })} footer={[<Button key="back" onClick={() => setErrorModal({ open: false, content: '' })}>Close</Button>]}>
<Text strong>Error Message:</Text>
<pre style={{ marginTop: '8px', background: '#f5f5f5', padding: '12px', borderRadius: '4px', overflowX: 'auto', whiteSpace: 'pre-wrap', wordBreak: 'break-word' }}>{errorModal.content}</pre>
</Modal>
      
      <RunDetailsModal 
        run={detailsModal.run}
        open={detailsModal.open}
        onCancel={() => setDetailsModal({ open: false, run: null })}
      />
    </div>
  );
};

export default DiscoveryHistory;
```

## File: src/pages/DiscoveryPage/components/DiscoveryStatsBreakdown.jsx
```javascript
import React, { useState } from 'react';
import { Row, Col, Typography, Empty, Modal, Table } from 'antd';
import PieChartCard from './PieChartCard';
import FunnelChart from './FunnelChart'; // NEW: From Task 35
import { getDisqualifiedKeywords } from '../../../services/discoveryService';

const { Title, Text } = Typography;

const DiscoveryStatsBreakdown = ({ summary, runId }) => {
  const [modalVisible, setModalVisible] = useState(false);
  const [modalTitle, setModalTitle] = useState('');
  const [modalData, setModalData] = useState([]);
  const [modalLoading, setModalLoading] = useState(false);

  if (!summary) {
    return <Empty description="No summary data available for this run." />;
  }

  const handleReasonClick = async (reason) => {
    setModalTitle(`Disqualified Keywords: ${reason}`);
    setModalVisible(true);
    setModalLoading(true);
    try {
      const data = await getDisqualifiedKeywords(runId, reason);
      setModalData(data);
    } catch (error) {
      console.error('Failed to fetch disqualified keywords:', error);
    } finally {
      setModalLoading(false);
    }
  };

  // Destructure with defaults to prevent errors if fields are missing
  const {
    source_counts = {},
    disqualification_reasons = {},
    total_raw_count = 0,
    total_unique_count = 0,
    disqualified_count = 0,
    final_added_to_db = 0,
    final_qualified_count = 0
  } = summary;

  const modalColumns = [
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      key: 'keyword',
    },
    {
      title: 'Search Volume',
      dataIndex: ['keyword_info', 'search_volume'],
      key: 'search_volume',
    },
  ];

  return (
    <div style={{ padding: '16px', backgroundColor: '#fafafa' }}>
      <Row gutter={[32, 32]}>
        {/* Section 1: Keyword Sources */}
        <Col xs={24} md={12} lg={8}>
          <PieChartCard title="Keyword Sources" data={source_counts} />
        </Col>

        {/* Section 2: Processing Funnel (Visualized) */}
        <Col xs={24} lg={16}>
            <FunnelChart 
                totalRaw={total_raw_count}
                unique={total_unique_count}
                qualified={final_qualified_count}
                disqualified={disqualified_count}
                addedToDB={final_added_to_db}
            />
        </Col>

        {/* Section 3: Disqualification Reasons */}
        <Col xs={24} md={12} lg={8}>
          <PieChartCard title="Disqualification Reasons" data={disqualification_reasons} onSliceClick={handleReasonClick} />
        </Col>
      </Row>
      <Modal
        title={modalTitle}
        open={modalVisible}
        onCancel={() => setModalVisible(false)}
        footer={null}
        width={800}
      >
        <Table
          loading={modalLoading}
          dataSource={modalData}
          columns={modalColumns}
          rowKey="id"
          pagination={{ pageSize: 10 }}
        />
      </Modal>
    </div>
  );
};

export default DiscoveryStatsBreakdown;
```

## File: src/pages/DiscoveryPage/components/FilterBuilder.jsx
```javascript
import React, { useState } from 'react';
import { Select, Button, InputNumber, Row, Col } from 'antd';
import { PlusOutlined, DeleteOutlined } from '@ant-design/icons';

const { Option } = Select;

const FilterBuilder = ({ availableFilters, onChange }) => {
  const [filters, setFilters] = useState([{ field: null, operator: null, value: null }]);

  const handleFilterChange = (index, field, value) => {
    const newFilters = [...filters];
    newFilters[index][field] = value;

    // Reset operator and value if field changes
    if (field === 'field') {
      newFilters[index]['operator'] = null;
      newFilters[index]['value'] = null;
    }

    setFilters(newFilters);
    onChange(newFilters);
  };

  const addFilter = () => {
    const newFilters = [...filters, { field: null, operator: null, value: null }];
    setFilters(newFilters);
    onChange(newFilters);
  };

  const removeFilter = (index) => {
    const newFilters = filters.filter((_, i) => i !== index);
    setFilters(newFilters);
    onChange(newFilters);
  };

  const getOperatorsForField = (fieldName) => {
    const modeFilters = availableFilters?.filtersData?.modes.find(m => m.id === 'keyword_ideas')?.filters;
    const field = modeFilters?.find(f => f.name === fieldName);
    return field ? field.operators : [];
  };

  const getInputForField = (fieldName, index) => {
    const modeFilters = availableFilters?.filtersData?.modes.find(m => m.id === 'keyword_ideas')?.filters;
    const field = modeFilters?.find(f => f.name === fieldName);
    if (!field) return null;

    switch (field.type) {
      case 'number':
        return <InputNumber value={filters[index].value} onChange={(val) => handleFilterChange(index, 'value', val)} />;
      case 'select':
        return (
          <Select
            style={{ width: 120 }}
            value={filters[index].value}
            onChange={(val) => handleFilterChange(index, 'value', val)}
          >
            {field.options.map(opt => <Option key={opt} value={opt}>{opt}</Option>)}
          </Select>
        );
      default:
        return null;
    }
  };

  return (
    <div>
      {filters.map((filter, index) => (
        <Row key={index} gutter={8} style={{ marginBottom: 8 }}>
          <Col>
            <Select
              style={{ width: 200 }}
              placeholder="Select field"
              value={filter.field}
              onChange={(val) => handleFilterChange(index, 'field', val)}
            >
              {availableFilters?.filters.map(f => <Option key={f.name} value={f.name}>{f.label}</Option>)}
            </Select>
          </Col>
          <Col>
            <Select
              style={{ width: 80 }}
              placeholder="Op"
              value={filter.operator}
              onChange={(val) => handleFilterChange(index, 'operator', val)}
              disabled={!filter.field}
            >
              {getOperatorsForField(filter.field).map(op => <Option key={op} value={op}>{op}</Option>)}
            </Select>
          </Col>
          <Col>
            {getInputForField(filter.field, index)}
          </Col>
          <Col>
            <Button icon={<DeleteOutlined />} onClick={() => removeFilter(index)} danger />
          </Col>
        </Row>
      ))}
      <Button type="dashed" onClick={addFilter} icon={<PlusOutlined />} disabled={filters.length >= 8}>
        Add Filter ({filters.length}/8)
      </Button>
    </div>
  );
};

export default FilterBuilder;
```

## File: src/pages/DiscoveryPage/components/FunnelChart.css
```css
/* Styling for the FunnelChart component */
.funnel-chart-container {
  background-color: #f9f9f9; /* Light background for the expanded row */
  padding: 24px;
  border-radius: 8px;
  border: 1px solid #e8e8e8;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.09);
  margin-bottom: 24px;
}

.funnel-steps {
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  position: relative;
  min-height: 150px; /* Ensure some height for visualization */
}

.funnel-step {
  height: 30px; /* Fixed height for each step */
  margin-bottom: 5px; /* Spacing between steps */
  border-radius: 4px;
  display: flex;
  justify-content: center;
  align-items: center;
  color: white;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.3s ease-in-out;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.funnel-step:hover {
  transform: scale(1.02);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.funnel-value {
  color: white !important;
}
```

## File: src/pages/DiscoveryPage/components/FunnelChart.jsx
```javascript
import React from 'react';
import { Typography, Row, Col, Statistic, Tooltip } from 'antd';
import './FunnelChart.css'; // Specific styles for the funnel chart

const { Text, Title } = Typography;

const FunnelChart = ({ totalRaw = 0, unique = 0, qualified = 0, disqualified = 0, addedToDB = 0 }) => {
  const data = [
    { label: "Total Found", value: totalRaw },
    { label: "Unique Keywords", value: unique },
    { label: "Qualified Keywords", value: qualified },
    { label: "Disqualified", value: disqualified },
    { label: "Added to Pipeline", value: addedToDB },
  ];

  const getColor = (label) => {
    switch(label) {
      case "Total Found": return "#1890ff";
      case "Unique Keywords": return "#2db7f5";
      case "Qualified Keywords": return "#52c41a";
      case "Disqualified": return "#f5222d";
      case "Added to Pipeline": return "#722ed1";
      default: return "#d9d9d9";
    }
  };

  return (
    <div className="funnel-chart-container">
      <Title level={5} style={{ marginBottom: '24px', textAlign: 'center' }}>Discovery Funnel</Title>
      <div className="funnel-steps">
        {data.map((item, index) => (
          <Tooltip title={item.label} key={index}>
            <div className="funnel-step" style={{ 
                backgroundColor: getColor(item.label),
                width: `${Math.max(20, (item.value / totalRaw) * 100)}%`, // Scale width
                zIndex: data.length - index // Ensure larger bars are behind
            }}>
              <Text strong className="funnel-value">{item.value.toLocaleString()}</Text>
            </div>
          </Tooltip>
        ))}
      </div>
      <Row gutter={[16, 16]} justify="space-around" style={{ marginTop: '24px' }}>
        {data.map((item, index) => (
          <Col key={index} span={Math.floor(24 / data.length)}>
            <Statistic 
              title={item.label} 
              value={item.value.toLocaleString()} 
              valueStyle={{ color: getColor(item.label) }} 
            />
          </Col>
        ))}
      </Row>
    </div>
  );
};

export default FunnelChart;
```

## File: src/pages/DiscoveryPage/components/PieChartCard.jsx
```javascript
import React from 'react';
import { Card, Typography, Empty, Tooltip } from 'antd';
import { PieChart, Pie, Cell, Tooltip as RechartsTooltip, Legend, ResponsiveContainer } from 'recharts';

const { Title } = Typography;

const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#AF19FF', '#FF19AF'];

const PieChartCard = ({ title, data, onSliceClick }) => {
  const chartData = Object.entries(data).map(([name, value]) => ({ name, value }));

  if (chartData.length === 0) {
    return (
      <Card>
        <Title level={5} style={{ marginBottom: '16px' }}>{title}</Title>
        <Empty description={`No ${title.toLowerCase()} data`} />
      </Card>
    );
  }

  const renderLegend = (props) => {
    const { payload } = props;
    return (
      <ul style={{ listStyle: 'none', padding: '0', margin: '0', maxHeight: '300px', overflowY: 'auto' }}>
        {payload.map((entry, index) => {
          const { value, color } = entry;
          const maxLength = 40;
          const isTruncated = value.length > maxLength;
          const truncatedValue = isTruncated ? `${value.substring(0, maxLength)}...` : value;

          return (
            <li key={`item-${index}`} style={{ marginBottom: '4px', display: 'flex', alignItems: 'center' }}>
              <span style={{ width: '10px', height: '10px', backgroundColor: color, marginRight: '10px', display: 'inline-block' }}></span>
              {isTruncated ? (
                <Tooltip title={value}>
                  <span style={{ cursor: 'default' }}>{truncatedValue}</span>
                </Tooltip>
              ) : (
                <span>{value}</span>
              )}
            </li>
          );
        })}
      </ul>
    );
  };


  return (
    <Card>
      <Title level={5} style={{ marginBottom: '16px' }}>{title}</Title>
      <ResponsiveContainer width="100%" height={300}>
        <PieChart>
          <Pie
            data={chartData}
            cx="50%"
            cy="50%"
            labelLine={false}
            outerRadius={80}
            fill="#8884d8"
            dataKey="value"
            nameKey="name"
            onClick={(data) => onSliceClick && onSliceClick(data.name)}
          >
            {chartData.map((entry, index) => (
              <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
            ))}
          </Pie>
          <RechartsTooltip />
          <Legend content={renderLegend} />
        </PieChart>
      </ResponsiveContainer>
    </Card>
  );
};

export default PieChartCard;
```

## File: src/pages/DiscoveryPage/components/RunDetailsModal.jsx
```javascript
import React from 'react';
import { Modal, Tag, Row, Col, Descriptions, Statistic, Steps, Card, Typography } from 'antd';
import { formatDistanceStrict } from 'date-fns';
import PieChartCard from './PieChartCard';

const { Title, Text } = Typography;
const { Step } = Steps;

const STATUS_CONFIG = {
  completed: { color: 'success', text: 'Completed' },
  failed: { color: 'error', text: 'Failed' },
  running: { color: 'processing', text: 'Running' },
  pending: { color: 'default', text: 'Pending' },
};

const RunDetailsModal = ({ run, open, onCancel }) => {
  if (!run) return null;

  const {
    id,
    start_time,
    end_time,
    status,
    parameters = {},
    results_summary = {},
  } = run;

  const {
    total_cost = 0,
    source_counts = {},
    total_raw_count = 0,
    total_unique_count = 0,
    final_qualified_count = 0,
    duplicates_removed = 0,
    final_added_to_db = 0,
    disqualification_reasons = {},
  } = results_summary;

  const statusInfo = STATUS_CONFIG[status] || STATUS_CONFIG.pending;

  return (
    <Modal
      title={
        <div style={{ display: 'flex', alignItems: 'center' }}>
          <Title level={4} style={{ margin: 0 }}>Discovery Run #{id}</Title>
          <Tag color={statusInfo.color} style={{ marginLeft: '12px' }}>{statusInfo.text}</Tag>
        </div>
      }
      open={open}
      onCancel={onCancel}
      footer={null}
      width="80vw"
      style={{ top: 20 }}
    >
      {/* Key Metrics */}
      <Row gutter={[32, 16]} style={{ marginBottom: '24px' }}>
        <Col><Statistic title="Total Cost" prefix="$" value={total_cost.toFixed(2)} /></Col>
        <Col><Statistic title="Run Duration" value={end_time ? formatDistanceStrict(new Date(end_time), new Date(start_time)) : 'N/A'} /></Col>
        <Col><Statistic title="Keywords Found" value={total_unique_count} /></Col>
        <Col><Statistic title="Added to Pipeline" value={final_added_to_db} valueStyle={{ color: '#3f8600' }} /></Col>
      </Row>

      {/* Processing Funnel */}
      <Card title="Processing Funnel" style={{ marginBottom: '24px' }}>
        <Steps current={5} size="small">
          <Step title="Total Found" description={`${total_raw_count.toLocaleString()}`} />
          <Step title="Unique" description={`${total_unique_count.toLocaleString()}`} />
          <Step title="Qualified" description={`${final_qualified_count.toLocaleString()}`} />
          <Step title="Duplicates Removed" description={`${duplicates_removed.toLocaleString()}`} />
          <Step title="Added to DB" description={<Text strong style={{color: '#3f8600'}}>{final_added_to_db.toLocaleString()}</Text>} />
        </Steps>
      </Card>

      <Row gutter={[24, 24]}>
        {/* Parameters */}
        <Col xs={24} lg={8}>
          <Card title="Run Parameters">
            <Descriptions bordered column={1} size="small">
              <Descriptions.Item label="Seed Keywords">
                {(parameters.seed_keywords || []).map(kw => <Tag key={kw}>{kw}</Tag>)}
              </Descriptions.Item>
              {Object.entries(parameters.filters_override || {}).map(([key, value]) => (
                <Descriptions.Item key={key} label={key.replace(/_/g, ' ')}>{String(value)}</Descriptions.Item>
              ))}
            </Descriptions>
          </Card>
        </Col>

        {/* Visualizations */}
        <Col xs={24} lg={16}>
          <Row gutter={[24, 24]}>
            <Col xs={24} md={12}>
              <PieChartCard title="Keyword Sources" data={source_counts} />
            </Col>
            <Col xs={24} md={12}>
              <PieChartCard title="Disqualification Reasons" data={disqualification_reasons} />
            </Col>
          </Row>
        </Col>
      </Row>
    </Modal>
  );
};

export default RunDetailsModal;
```

## File: src/pages/DiscoveryPage/components/RunDetailsPage.jsx
```javascript
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { Table, Tag, Spin, Alert, Typography, Button, Row, Col } from 'antd';
import { ArrowLeftOutlined, CheckCircleOutlined } from '@ant-design/icons';
import { getKeywordsForRun } from '../../../services/discoveryService';
import { overrideDisqualification } from '../../../services/opportunitiesService';
import { useNotifications } from '../../../hooks/useNotifications';

const { Title, Text } = Typography;

const RunDetailsPage = () => {
  const { runId } = useParams();
  const navigate = useNavigate();
  const [keywords, setKeywords] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [updatingIds, setUpdatingIds] = useState(new Set());
  const { showNotification } = useNotifications();

  useEffect(() => {
    const fetchKeywords = async () => {
      try {
        setLoading(true);
        const response = await getKeywordsForRun(runId);
        setKeywords(response || []);
      } catch (err) {
        setError('Failed to fetch keyword details for this run.');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchKeywords();
  }, [runId]);

  const handleOverride = async (opportunityId) => {
    setUpdatingIds(prev => new Set(prev).add(opportunityId));
    try {
      await overrideDisqualification(opportunityId);
      showNotification('success', 'Keyword Re-qualified', 'The keyword has been moved to the pending queue.');
      // Optimistically update the UI
      setKeywords(prevKeywords => 
        prevKeywords.map(kw => 
          kw.id === opportunityId 
            ? { ...kw, blog_qualification_status: 'passed_manual_override', blog_qualification_reason: 'Manually overridden by user.' }
            : kw
        )
      );
    } catch (err) {
      showNotification('error', 'Override Failed', err.message || 'Could not re-qualify the keyword.');
      console.error(err);
    } finally {
      setUpdatingIds(prev => {
        const newSet = new Set(prev);
        newSet.delete(opportunityId);
        return newSet;
      });
    }
  };

  const columns = [
    {
      title: 'Keyword',
      dataIndex: 'keyword',
      key: 'keyword',
      sorter: (a, b) => a.keyword.localeCompare(b.keyword),
    },
    {
      title: 'Qualification Status',
      dataIndex: 'blog_qualification_status',
      key: 'blog_qualification_status',
      render: (status) => {
        let color = 'default';
        if (status === 'passed') color = 'success';
        else if (status === 'failed' || status === 'rejected') color = 'error';
        else if (status === 'passed_manual_override') color = 'processing';
        return (
          <Tag color={color}>
            {status ? status.replace(/_/g, ' ').toUpperCase() : 'N/A'}
          </Tag>
        );
      },
      filters: [
        { text: 'Passed', value: 'passed' },
        { text: 'Failed', value: 'failed' },
        { text: 'Override', value: 'passed_manual_override' },
      ],
      onFilter: (value, record) => record.blog_qualification_status === value,
    },
    {
      title: 'Reason',
      dataIndex: 'blog_qualification_reason',
      key: 'blog_qualification_reason',
      render: (reason) => reason || <Text type="secondary">N/A</Text>,
    },
    {
        title: 'Search Volume',
        dataIndex: ['keyword_info', 'search_volume'],
        key: 'search_volume',
        sorter: (a, b) => (a.keyword_info?.search_volume || 0) - (b.keyword_info?.search_volume || 0),
        render: (sv) => sv ? sv.toLocaleString() : 'N/A',
    },
    {
        title: 'Keyword Difficulty',
        dataIndex: ['keyword_properties', 'keyword_difficulty'],
        key: 'keyword_difficulty',
        sorter: (a, b) => (a.keyword_properties?.keyword_difficulty || 0) - (b.keyword_properties?.keyword_difficulty || 0),
        render: (kd) => kd || 'N/A',
    },
    {
      title: 'Actions',
      key: 'actions',
      render: (_, record) => {
        const isFailed = record.blog_qualification_status === 'failed' || record.blog_qualification_status === 'rejected';
        if (isFailed) {
          return (
            <Button 
              type="primary" 
              ghost 
              size="small"
              icon={<CheckCircleOutlined />}
              onClick={() => handleOverride(record.id)}
              loading={updatingIds.has(record.id)}
            >
              Re-qualify
            </Button>
          );
        }
        return null;
      },
    },
  ];

  if (loading) {
    return <Spin tip="Loading keywords..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (error) {
    return <Alert message="Error" description={error} type="error" showIcon />;
  }

  return (
    <>
      <div style={{ padding: '16px 24px', backgroundColor: '#fff', borderBottom: '1px solid #f0f0f0' }}>
        <Row align="middle" gutter={16}>
          <Col>
            <Button icon={<ArrowLeftOutlined />} onClick={() => navigate(-1)} />
          </Col>
          <Col>
            <Title level={4} style={{ margin: 0 }}>
              Keywords for Discovery Run #{runId}
            </Title>
            <Text type="secondary">{keywords.length.toLocaleString()} keywords found</Text>
          </Col>
        </Row>
      </div>
      <div style={{ padding: '24px' }}>
        <Table
          columns={columns}
          dataSource={keywords}
          rowKey="id"
          loading={loading}
          pagination={{ pageSize: 50 }}
        />
      </div>
    </>
  );
};

export default RunDetailsPage;
```

## File: src/pages/DiscoveryPage/hooks/useDiscoveryFilters.js
```javascript
import { useQuery } from 'react-query';
import apiClient from '../../../services/apiClient';

const fetchDiscoveryFilters = async () => {
  const data = await apiClient.get('/api/discovery/available-filters');
  return data;
};

export const useDiscoveryFilters = () => {
  const { data, isLoading, isError } = useQuery('discoveryFilters', fetchDiscoveryFilters, {
    staleTime: Infinity, // This data is static, so we can cache it indefinitely
    cacheTime: Infinity,
  });

  return {
    filtersData: data,
    isLoading,
    isError,
  };
};
```

## File: src/pages/DiscoveryPage/hooks/useDiscoveryRuns.js
```javascript
import { useState, useEffect } from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import {
  getDiscoveryRuns,
  startDiscoveryRun,
  rerunDiscoveryRun,
  getJobStatus,
} from '../../../services/discoveryService';
import { useClient } from '../../../hooks/useClient';
import { useNotifications } from '../../../context/NotificationContext';

export const useDiscoveryRuns = () => {
  const queryClient = useQueryClient();
  const { clientId } = useClient();
  const { showNotification } = useNotifications();
  const [page, setPage] = useState(1);

  // Query to fetch discovery run history
  const {
    data,
    isLoading, // True on initial fetch
    isError, // True if query failed
    error, // Error object
  } = useQuery(
    ['discoveryRuns', clientId, page], // Unique query key, depends on clientId and page
    () => getDiscoveryRuns(clientId, page), // Function to fetch data
    {
      enabled: !!clientId, // Only run query if clientId is available
      keepPreviousData: true, // Keep previous data while fetching new page
    }
  );

  // Poll for updates on running jobs
  useEffect(() => {
    const runningJobs = data?.items?.filter(run => run.status === 'running' && run.job_id);
    if (runningJobs && runningJobs.length > 0) {
      const interval = setInterval(() => {
        runningJobs.forEach(run => {
          getJobStatus(run.job_id).then(job => {
            if (job.status === 'completed' || job.status === 'failed') {
              queryClient.invalidateQueries(['discoveryRuns', clientId]);
            }
          });
        });
      }, 5000); // Poll every 5s

      return () => clearInterval(interval);
    }
  }, [data, clientId, queryClient]);

  // Mutation for starting a new discovery run
  const startRunMutation = useMutation(startDiscoveryRun, {
    // Optimistic update logic
    onMutate: async (newRunRequest) => {
      await queryClient.cancelQueries(['discoveryRuns', clientId]); // Cancel any outgoing refetches

      const previousRuns = queryClient.getQueryData(['discoveryRuns', clientId, page]); // Snapshot previous state

      // Optimistically add a temporary 'running' job to the cache
      queryClient.setQueryData(['discoveryRuns', clientId, 1], (old) => ({
        ...old,
        items: [
          {
            id: `temp-${Date.now()}`, // Temporary ID for optimistic update
            start_time: new Date().toISOString(),
            status: 'running',
            parameters: { seed_keywords: newRunRequest.runData.seed_keywords },
            results_summary: { progress: 0 }, // Initial progress
            error_message: null,
          },
          ...(old?.items || []),
        ]
      }));
      setPage(1); // Go to the first page to see the new run

      return { previousRuns }; // Return context for rollback
    },
    onError: (err, newRun, context) => {
      queryClient.setQueryData(['discoveryRuns', clientId, page], context.previousRuns); // Rollback on error
      showNotification('error', 'Failed to start discovery run', err.message);
    },
    onSuccess: (data) => {
       showNotification('success', 'Discovery run started successfully!', `Job ID: ${data.job_id}`);
    },
    onSettled: () => {
      queryClient.invalidateQueries(['discoveryRuns', clientId]); // Refetch to get actual server state
    },
  });
  
  // Mutation for re-running an existing discovery job
  const rerunMutation = useMutation(rerunDiscoveryRun, {
    onSuccess: (data) => {
      showNotification('success', 'Re-run started successfully!', `Job ID: ${data.job_id}`);
      queryClient.invalidateQueries(['discoveryRuns', clientId]); // Refetch history to show new job
    },
    onError: (err) => {
      showNotification('error', 'Failed to start re-run', err.message);
    },
  });

  return {
    runs: data?.items || [],
    totalRuns: data?.total_items || 0,
    page,
    setPage,
    isLoading,
    isError,
    error,
    startRunMutation,
    rerunMutation,
  };
};
```

## File: src/pages/DiscoveryPage/DiscoveryPage.jsx
```javascript
import React, { useState } from 'react';
import { Layout, Typography, Spin, Alert, Card, Divider, message } from 'antd';
import { useNavigate } from 'react-router-dom'; // Import useNavigate
import { useDiscoveryRuns } from './hooks/useDiscoveryRuns';
import DiscoveryForm from './components/DiscoveryForm';
import DiscoveryHistory from './components/DiscoveryHistory';
import { useClient } from '../../hooks/useClient';
import CostConfirmationModal from '../../components/CostConfirmationModal';
import { estimateActionCost } from '../../services/orchestratorService';

const { Content } = Layout;
const { Title } = Typography;

const DiscoveryPage = () => {
  const { runs, isLoading, isError, error, startRunMutation, rerunMutation } = useDiscoveryRuns();
  const { clientId } = useClient();
  const navigate = useNavigate(); // Initialize navigate

  const handleRerun = (runId) => {
      rerunMutation.mutate(runId);
  }

  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Spin size="large" tip="Loading Discovery Hub..." />
      </div>
    );
  }

  if (isError) {
    return (
        <Alert
            message="Error"
            description={error.message || "Failed to load discovery run history. Please try again."}
            type="error"
            showIcon
            style={{ margin: '16px' }}
        />
    );
  }

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Title level={2}>Keyword Discovery</Title>
        <Card>
          <DiscoveryForm
            isSubmitting={startRunMutation.isLoading}
            onSubmit={({ runData }) => {
              startRunMutation.mutate({ clientId, runData }, {
                onSuccess: (data) => {
                  const newRun = data.run_summary;
                  message.success(`Discovery run #${newRun.id} started successfully!`);
                  navigate(`/discovery/run/${newRun.id}`);
                },
                onError: (err) => {
                  message.error(`Failed to start discovery run: ${err.message}`);
                }
              });
            }}
          />
        </Card>

        <Divider />

        <DiscoveryHistory
            runs={runs}
            isLoading={startRunMutation.isLoading || rerunMutation.isLoading} 
            onRerun={handleRerun}
            isRerunning={rerunMutation.isLoading}
        />
      </Content>
    </Layout>
  );
};

export default DiscoveryPage;
```

## File: src/pages/NotFoundPage/NotFoundPage.jsx
```javascript
import React from 'react';
import { Result, Button } from 'antd';
import { Link } from 'react-router-dom';

const NotFoundPage = () => (
  <Result
    status="404"
    title="404"
    subTitle="Sorry, the page you visited does not exist."
    extra={<Button type="primary"><Link to="/">Back Home</Link></Button>}
  />
);

export default NotFoundPage;
```

## File: src/pages/OpportunitiesPage/components/ScoreBreakdownModal.jsx
```javascript
import React, { useState, useEffect } from 'react';
import { Modal, Typography, Descriptions, Tag, Row, Col, Alert, Space, Spin, Popover, Progress } from 'antd';
import {
  BarChartOutlined, FireOutlined, ThunderboltOutlined, CalendarOutlined, GlobalOutlined, SmileOutlined,
  BuildOutlined, StarOutlined, UsergroupAddOutlined, ApartmentOutlined, WarningOutlined, RiseOutlined,
  DashboardOutlined, BulbOutlined, InfoCircleOutlined
} from '@ant-design/icons';
import { getScoreNarrative } from '../../../services/orchestratorService';

const { Title, Text, Paragraph } = Typography;

const factorExplanations = {
  ease_of_ranking: "How hard it is to rank on the first page of Google for this keyword. It looks at competitor strength and keyword difficulty.",
  traffic_potential: "An estimate of the traffic you could get if you rank for this keyword, based on search volume and click-through rates.",
  commercial_intent: "How likely a user searching for this keyword is to make a purchase or take a commercial action.",
  growth_trend: "Whether this keyword is becoming more or less popular over time.",
  serp_features: "Measures the presence of special search results like Featured Snippets or People Also Ask boxes, which can affect click-through rates.",
  serp_volatility: "How often the search results for this keyword change. High volatility can mean it's easier to break in, but also harder to hold a position.",
  competitor_weakness: "Analyzes the weaknesses of the top-ranking competitors, such as their backlink profiles and domain authority.",
  serp_crowding: "How many non-traditional results (like ads, images, videos) are on the page, which can push organic results down.",
  keyword_structure: "Analyzes the keyword itself, like its length. Longer keywords are often more specific and easier to rank for.",
  serp_threat: "Identifies major, authoritative domains (like Wikipedia, government sites) that are very difficult to outrank.",
  volume_volatility: "How much the search volume fluctuates month-to-month. High volatility can indicate seasonality.",
  serp_freshness: "How recently the search results have been updated. Older results can be easier to displace.",
  competitor_performance: "A technical analysis of competitor websites, looking at things like page load speed and mobile-friendliness.",
};


const ScoreBreakdownModal = ({ open, onCancel, opportunity }) => {
  const [narrative, setNarrative] = useState('');
  const [isLoadingNarrative, setIsLoadingNarrative] = useState(false);

  useEffect(() => {
    if (open && opportunity?.id) {
      setIsLoadingNarrative(true);
      getScoreNarrative(opportunity.id)
        .then(response => {
          setNarrative(response.data.narrative);
        })
        .catch(err => {
          console.error("Failed to fetch score narrative:", err);
          setNarrative("Could not load the strategic summary.");
        })
        .finally(() => {
          setIsLoadingNarrative(false);
        });
    } else {
      setNarrative('');
    }
  }, [open, opportunity]);

  const keyword = opportunity?.keyword;
  const scoreBreakdown = opportunity?.score_breakdown || opportunity?.full_data?.score_breakdown;

  if (!scoreBreakdown) {
    return <Modal title="Score Breakdown" open={open} onCancel={onCancel} footer={null}><Alert message="No score breakdown available for this opportunity." type="info" showIcon /></Modal>;
  }

  const getScoreColor = (score) => {
    if (score >= 80) return 'success';
    if (score >= 60) return 'processing';
    if (score >= 40) return 'warning';
    return 'error';
  };

  const renderFactor = (factorKey, icon) => {
    const factor = scoreBreakdown[factorKey];
    if (!factor) return null;

    const mainExplanation = factorExplanations[factorKey] || "No explanation available.";

    return (
      <Col span={24} style={{ marginBottom: 16 }}>
        <div style={{ background: '#fafafa', padding: '12px 16px', borderRadius: '8px' }}>
          <Row align="middle" justify="space-between">
            <Col>
              <Space align="center">
                {icon}
                <Title level={5} style={{ margin: 0 }}>{factor.name}</Title>
                <Popover content={<Paragraph style={{ maxWidth: 300 }}>{mainExplanation}</Paragraph>} trigger="hover">
                  <InfoCircleOutlined style={{ color: 'rgba(0, 0, 0, 0.45)', cursor: 'pointer' }} />
                </Popover>
              </Space>
            </Col>
            <Col>
              <Space>
                <Text type="secondary" style={{ fontSize: '0.9em' }}>Weight: {factor.weight || 0}%</Text>
                <Progress type="circle" percent={factor.score} width={40} format={percent => `${percent}`} status={getScoreColor(factor.score)} />
              </Space>
            </Col>
          </Row>
          <Descriptions column={1} size="small" style={{ marginTop: 12 }}>
            {Object.entries(factor.breakdown || {}).map(([subFactorKey, subFactor]) => (
              <Descriptions.Item key={subFactorKey} label={<Text strong>{subFactorKey}</Text>}>
                <Row justify="space-between" align="top">
                  <Col span={16}>
                    <Space direction="vertical" size={0}>
                      <Text>{subFactor.value}</Text>
                      {subFactor.explanation && <Paragraph type="secondary" style={{ margin: 0, fontSize: '0.85em' }}>{subFactor.explanation}</Paragraph>}
                    </Space>
                  </Col>
                  <Col span={4} style={{ textAlign: 'right' }}>
                    {subFactor.score !== undefined && <Tag color={getScoreColor(subFactor.score)}>{subFactor.score?.toFixed(0)}</Tag>}
                  </Col>
                </Row>
              </Descriptions.Item>
            ))}
             {factor.breakdown?.message && <Alert message={factor.breakdown.message} type="warning" showIcon style={{width: '100%'}}/>}
          </Descriptions>
        </div>
      </Col>
    );
  };

  return (
    <Modal
      title={<Title level={4} style={{ margin: 0 }}>Strategic Score Breakdown: &quot;{keyword}&quot;</Title>}
      open={open}
      onCancel={onCancel}
      footer={null}
      width={800}
    >
      {isLoadingNarrative ? (
        <Spin tip="Loading AI-powered summary..." />
      ) : (
        narrative && <Alert message="Strategic Summary" description={<Paragraph style={{ whiteSpace: 'pre-wrap' }}>{narrative}</Paragraph>} type="info" showIcon icon={<BulbOutlined />} style={{ marginBottom: '24px' }} />
      )}
      <Row gutter={[16, 16]}>
        {renderFactor('ease_of_ranking', <BarChartOutlined />)}
        {renderFactor('traffic_potential', <FireOutlined />)}
        {renderFactor('commercial_intent', <ThunderboltOutlined />)}
        {renderFactor('growth_trend', <RiseOutlined />)}
        {renderFactor('serp_features', <StarOutlined />)}
        {renderFactor('competitor_weakness', <BuildOutlined />)}
        {renderFactor('serp_volatility', <SmileOutlined />)}
        {renderFactor('serp_crowding', <UsergroupAddOutlined />)}
        {renderFactor('keyword_structure', <ApartmentOutlined />)}
        {renderFactor('serp_threat', <WarningOutlined />)}
        {renderFactor('volume_volatility', <CalendarOutlined />)}
        {renderFactor('serp_freshness', <GlobalOutlined />)}
        {renderFactor('competitor_performance', <DashboardOutlined />)}
      </Row>
    </Modal>
  );
};

export default ScoreBreakdownModal;
```

## File: src/pages/OpportunitiesPage/hooks/useOpportunities.js
```javascript
import { useQuery } from 'react-query';
import { useState, useMemo, useEffect } from 'react';
import { getOpportunities, getDashboardStats } from '../../../services/opportunitiesService';
import { useClient } from '../../../hooks/useClient';

export const useOpportunities = () => {
  const { clientId } = useClient();
  const [pagination, setPagination] = useState({ current: 1, pageSize: 20, total: 0 });
  const [activeStatus, setActiveStatus] = useState('review');
  const [sorter, setSorter] = useState({ field: 'strategic_score', order: 'descend' });
  const [statusCounts, setStatusCounts] = useState({});

  const { data: statsData, isLoading: isLoadingStats } = useQuery(
    ['dashboardStats', clientId],
    () => getDashboardStats(clientId),
    {
      enabled: !!clientId,
      onSuccess: (data) => {
        if (data.status_counts) {
          setStatusCounts(data.status_counts);
          if (!activeStatus && Object.keys(data.status_counts).length > 0) {
            setActiveStatus(Object.keys(data.status_counts)[0]);
          }
        }
      },
    }
  );
  
  const { data: opportunitiesData, isLoading, isError, error, refetch } = useQuery(
    ['opportunities', clientId, pagination.current, pagination.pageSize, sorter, activeStatus],
    () => getOpportunities(clientId, { 
      page: pagination.current, 
      limit: pagination.pageSize, 
      sort_by: sorter.field, 
      sort_direction: sorter.order === 'ascend' ? 'asc' : 'desc',
      status: activeStatus 
    }),
    {
      enabled: !!clientId,
      staleTime: 60 * 1000,
      onSuccess: (data) => {
        setPagination(prev => ({ ...prev, total: data.total_items || 0 }));
      }
    }
  );

  const opportunities = useMemo(() => opportunitiesData?.items || [], [opportunitiesData]);

  const handleTableChange = (newPagination, newFilters, newSorter) => {
    setPagination(prev => ({ ...prev, current: newPagination.current, pageSize: newPagination.pageSize }));
    
    const effectiveSorter = Array.isArray(newSorter) ? newSorter[0] : newSorter;
    if (effectiveSorter?.field) {
        setSorter({ field: effectiveSorter.field, order: effectiveSorter.order });
    } else {
        setSorter({ field: 'strategic_score', order: 'descend' });
    }
    refetch();
  };

  return {
    opportunities,
    isLoading: isLoading || isLoadingStats,
    isError, error,
    pagination,
    handleTableChange,
    activeStatus, setActiveStatus,
    statusCounts,
    refetchOpportunities: refetch
  };
};
```

## File: src/pages/OpportunitiesPage/hooks/useOpportunities.refactored.js
```javascript
import { useQuery } from 'react-query';
import { useState } from 'react';
import { getOpportunities } from '../../../services/opportunitiesService';
import { useClient } from '../../../hooks/useClient';

export const useOpportunities = () => {
  const { clientId } = useClient();
  const [pagination, setPagination] = useState({ current: 1, pageSize: 20, total: 0 });
  const [activeStatus, setActiveStatus] = useState('review');
  const [sorter, setSorter] = useState({ field: 'strategic_score', order: 'descend' });
  const [keyword, setKeyword] = useState('');

  const { data, isLoading, isError, error, refetch } = useQuery(
    ['opportunities', clientId, pagination.current, pagination.pageSize, activeStatus, sorter, keyword],
    () => getOpportunities(clientId, {
      page: pagination.current,
      limit: pagination.pageSize,
      status: activeStatus,
      sort_by: sorter.field,
      sort_direction: sorter.order === 'ascend' ? 'asc' : 'desc',
      keyword: keyword,
    }),
    {
      enabled: !!clientId,
      staleTime: 60 * 1000, // Keep data fresh for 1 minute
      onSuccess: (response) => {
        setPagination(prev => ({ ...prev, total: response.total_items || 0 }));
      }
    }
  );

  const handleTableChange = (newPagination, newFilters, newSorter) => {
    setPagination(prev => ({ ...prev, current: newPagination.current, pageSize: newPagination.pageSize }));

    const effectiveSorter = Array.isArray(newSorter) ? newSorter[0] : newSorter;
    if (effectiveSorter?.field) {
        setSorter({ field: effectiveSorter.field, order: effectiveSorter.order });
    } else {
        // Reset to default sort if no specific column is sorted
        setSorter({ field: 'strategic_score', order: 'descend' });
    }
  };

  const handleSearch = (newKeyword) => {
    setKeyword(newKeyword);
  };

  return {
    opportunities: data?.items || [],
    isLoading,
    isError,
    error,
    pagination,
    handleTableChange,
    activeStatus,
    setActiveStatus,
    handleSearch,
    refetchOpportunities: refetch,
  };
};
```

## File: src/pages/OpportunitiesPage/OpportunitiesPage.css
```css
/* OpportunitiesPage.css */

.custom-tabs .ant-tabs-nav {
  background-color: #f0f2f5;
  padding: 0 16px;
  border-radius: 8px;
  margin-bottom: 16px;
}

.custom-tabs .ant-tabs-tab {
  padding: 12px 16px;
  font-size: 14px;
}

.custom-tabs .ant-tabs-tab-active {
  background-color: #ffffff;
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
}

.custom-tabs .ant-tabs-ink-bar {
  background-color: #1890ff;
}

.custom-tabs .ant-tag {
  font-weight: 900;
  font-size: 14px;
}
```

## File: src/pages/OpportunitiesPage/OpportunitiesPage.jsx
```javascript
import React from 'react';
import { Layout, Typography, Table, Tag, Button, Space, Tooltip, Modal, Card, Tabs } from 'antd';
import { RocketOutlined, EditOutlined, DeleteOutlined, ExclamationCircleOutlined } from '@ant-design/icons';
import { useOpportunities } from './hooks/useOpportunities';
import { useNotifications } from '../../context/NotificationContext';
import { useMutation, useQueryClient } from 'react-query';
import { startFullWorkflow, rejectOpportunity } from '../../services/orchestratorService';
import JobStatusIndicator from '../../components/JobStatusIndicator';
import { useJobs } from '../../context/JobContext';
import { getJobStatus } from '../../services/jobsService';
import { useNavigate } from 'react-router-dom';
import './OpportunitiesPage.css';

const { Content } = Layout;
const { Title, Text } = Typography;
const { confirm } = Modal;
const { TabPane } = Tabs;

const MAIN_STATUSES = [
  'review', 
  'paused_for_approval', 
  'generated', 
  'rejected', 
  'failed'
];

const statusColors = {
  review: 'blue',
  paused_for_approval: 'orange',
  generated: 'green',
  rejected: 'default',
  failed: 'red',
};

const OpportunitiesPage = () => {
  const { 
    opportunities, isLoading, pagination, 
    handleTableChange, activeStatus, setActiveStatus, statusCounts
  } = useOpportunities();
  const { showNotification } = useNotifications();
  const queryClient = useQueryClient();
  const navigate = useNavigate();
  const { startJob, updateJob, completeJob } = useJobs();

  const { mutate: startWorkflowMutation, isLoading: isStartingWorkflow } = useMutation(
    ({ opportunityId, override, opportunityKeyword }) => startFullWorkflow(opportunityId, override),
    {
      onSuccess: (data, variables) => {
        const { job_id } = data;
        const { opportunityKeyword } = variables;
        startJob(job_id, `Workflow started for "${opportunityKeyword}".`);

        const poll = setInterval(async () => {
          try {
            const statusData = await getJobStatus(job_id);
            if (statusData.status === 'completed' || statusData.status === 'failed') {
              updateJob(job_id, statusData.status, statusData.error || `Workflow for "${opportunityKeyword}" finished.`);
              completeJob(job_id);
              clearInterval(poll);
              queryClient.invalidateQueries('opportunities');
            } else {
              const lastLog = statusData.progress_log?.[statusData.progress_log.length - 1];
              updateJob(job_id, 'running', lastLog?.message || 'Processing...');
            }
          } catch (error) {
            updateJob(job_id, 'failed', 'Failed to get job status.');
            completeJob(job_id);
            clearInterval(poll);
          }
        }, 5000);
      },
      onError: (err, variables) => {
        const { opportunityKeyword } = variables;
        showNotification('error', `Workflow Failed for "${opportunityKeyword}"`, err.message)
      },
    }
  );

  const { mutate: rejectOpportunityMutation, isLoading: isRejecting } = useMutation(
    (opportunityId) => rejectOpportunity(opportunityId),
    {
      onSuccess: () => {
        showNotification('success', 'Opportunity Rejected', 'The opportunity has been marked as rejected.');
        queryClient.invalidateQueries('opportunities');
      },
      onError: (err) => showNotification('error', 'Rejection Failed', err.message),
    }
  );

  const showRejectConfirm = (opportunityId) => {
    confirm({
      title: 'Are you sure you want to reject this opportunity?',
      icon: <ExclamationCircleOutlined />,
      content: 'This action cannot be undone.',
      okText: 'Yes, Reject',
      okType: 'danger',
      cancelText: 'No',
      onOk() {
        rejectOpportunityMutation(opportunityId);
      },
    });
  };

  const renderActions = (_, record) => {
    const isFailed = ['failed', 'rejected'].includes(record.status);
    const isLoading = isStartingWorkflow || isRejecting;

    const buttons = [];

    switch (activeStatus) {
      case 'review':
        buttons.push(
          <Tooltip title="Run Workflow" key="run">
            <Button
              type="primary"
              icon={<RocketOutlined />}
              onClick={(e) => { 
                e.stopPropagation(); 
                console.log('Starting workflow for opportunity:', record.id, 'with override:', isFailed);
                startWorkflowMutation({ opportunityId: record.id, override: isFailed, opportunityKeyword: record.keyword }); 
              }}
              loading={isStartingWorkflow}
              disabled={isLoading}
            />
          </Tooltip>,
          <Tooltip title="Reject Opportunity" key="reject">
            <Button
              danger
              icon={<DeleteOutlined />}
              onClick={(e) => { e.stopPropagation(); showRejectConfirm(record.id); }}
              loading={isRejecting}
              disabled={isLoading}
            />
          </Tooltip>
        );
        break;
      case 'rejected':
      case 'failed':
        buttons.push(
          <Tooltip title="Run Workflow" key="run-failed">
            <Button
              type="primary"
              icon={<RocketOutlined />}
              onClick={(e) => { e.stopPropagation(); startWorkflowMutation({ opportunityId: record.id, override: true }); }}
              loading={isStartingWorkflow}
              disabled={isLoading}
            />
          </Tooltip>
        );
        break;
      default:
        break;
    }

    buttons.push(
      <Tooltip title="View Details" key="view">
        <Button 
          icon={<EditOutlined />} 
          onClick={(e) => { e.stopPropagation(); navigate(`/opportunities/${record.id}`)}} 
        />
      </Tooltip>
    );

    return <Space>{buttons}</Space>;
  };

  const baseColumns = [
    { title: 'Keyword', dataIndex: 'keyword', key: 'keyword', sorter: true, render: (text, record) => <a onClick={(e) => { e.stopPropagation(); navigate(`/opportunities/${record.id}`)}}>{text}</a> },
    { title: 'Search Volume', dataIndex: 'search_volume', key: 'search_volume', sorter: true, render: (sv) => sv ? sv.toLocaleString() : 'N/A' },
    { title: 'KD', dataIndex: 'keyword_difficulty', key: 'keyword_difficulty', sorter: true, render: (kd) => kd != null ? kd : 'N/A' },
  ];

  const rejectedColumns = [
    ...baseColumns,
    { 
      title: 'Rejection Reason', 
      dataIndex: 'blog_qualification_reason', 
      key: 'blog_qualification_reason',
      render: (reason) => reason || <Text type="secondary">No reason provided</Text>
    },
    { title: 'Actions', key: 'actions', fixed: 'right', render: renderActions },
  ];

  const defaultColumns = [
    ...baseColumns,
    { title: 'Strategic Score', dataIndex: 'strategic_score', key: 'strategic_score', sorter: true, render: (score) => score ? <strong>{score.toFixed(1)}</strong> : 'N/A' },
    { title: 'CPC', dataIndex: 'cpc', key: 'cpc', sorter: true, render: (cpc) => cpc ? `$${cpc.toFixed(2)}` : 'N/A' },
    { title: 'Actions', key: 'actions', fixed: 'right', render: renderActions },
  ];

  const columns = activeStatus === 'rejected' ? rejectedColumns : defaultColumns;

  return (
    <Layout style={{ padding: '24px' }}><Content>
      <Title level={2}>Content Opportunities</Title>
      <Card>
        <div className="custom-tabs">
          <Tabs activeKey={activeStatus} onChange={setActiveStatus}>
            {MAIN_STATUSES.map(status => (
              <TabPane 
                tab={
                  <span>
                    {status.replace(/_/g, ' ').toUpperCase()}
                    <Tag color={statusColors[status]} style={{ marginLeft: 8 }}>
                      {statusCounts[status] || 0}
                    </Tag>
                  </span>
                }
                key={status} 
              />
            ))}
          </Tabs>
        </div>
        <Table
          columns={columns}
          dataSource={opportunities}
          rowKey="id"
          loading={isLoading}
          pagination={pagination}
          onChange={handleTableChange}
          onRow={(record) => ({
            onClick: () => navigate(`/opportunities/${record.id}`),
            style: { cursor: 'pointer' },
          })}
          rowClassName="table-row-hover"
        />
      </Card>
    </Content></Layout>
  );
};

export default OpportunitiesPage;
```

## File: src/pages/opportunity-detail-page/components/ActionCenter.jsx
```javascript
import React from 'react';
import { Card, Button, Space, Alert, Modal } from 'antd';
import { CheckOutlined, ExperimentOutlined, RocketOutlined, DeleteOutlined, ExclamationCircleOutlined } from '@ant-design/icons';
import { useNotifications } from '../../../context/NotificationContext';
import { useMutation } from 'react-query';
import { approveAnalysis, startFullContentGeneration, startFullWorkflow, rejectOpportunity } from '../../../services/orchestratorService';

const { confirm } = Modal;

const ActionCenter = ({ status, opportunityId, overrides, refetch }) => {
  const { showNotification } = useNotifications();

  const { mutate: approveAnalysisMutation, isLoading: isApproving } = useMutation(
    () => approveAnalysis(opportunityId, overrides),
    {
      onSuccess: () => {
        showNotification('success', 'Analysis Approved', 'The content generation process has been initiated.');
        refetch();
      },
      onError: (error) => showNotification('error', 'Approval Failed', error.message),
    }
  );

  const { mutate: generateContentMutation, isLoading: isGenerating } = useMutation(
    (variables) => startFullContentGeneration(variables.opportunityId, variables.modelOverride, variables.temperature),
    {
      onSuccess: () => {
        showNotification('success', 'Content Generation Started', 'The AI is now generating the content.');
        refetch();
      },
      onError: (error) => showNotification('error', 'Generation Failed', error.message),
    }
  );

  const { mutate: startWorkflowMutation, isLoading: isStartingWorkflow } = useMutation(
    () => startFullWorkflow(opportunityId, ['failed', 'rejected'].includes(status)),
    {
      onSuccess: (data) => {
        showNotification('success', 'Workflow Started', `Job has been queued. Job ID: ${data.job_id}`);
        refetch();
      },
      onError: (err) => showNotification('error', 'Workflow Failed', err.message),
    }
  );

  const { mutate: rejectOpportunityMutation, isLoading: isRejecting } = useMutation(
    () => rejectOpportunity(opportunityId),
    {
      onSuccess: () => {
        showNotification('success', 'Opportunity Rejected', 'The opportunity has been marked as rejected.');
        refetch();
      },
      onError: (err) => showNotification('error', 'Rejection Failed', err.message),
    }
  );

  const showRejectConfirm = () => {
    confirm({
      title: 'Are you sure you want to reject this opportunity?',
      icon: <ExclamationCircleOutlined />,
      content: 'This action cannot be undone.',
      okText: 'Yes, Reject',
      okType: 'danger',
      cancelText: 'No',
      onOk: () => rejectOpportunityMutation(),
    });
  };

  const renderActions = () => {
    const isLoading = isApproving || isGenerating || isStartingWorkflow || isRejecting;

    switch (status) {
      case 'review':
        return (
          <Space>
            <Button type="primary" icon={<RocketOutlined />} onClick={() => startWorkflowMutation()} loading={isStartingWorkflow} disabled={isLoading}>
              Run Workflow
            </Button>
            <Button type="danger" icon={<DeleteOutlined />} onClick={showRejectConfirm} loading={isRejecting} disabled={isLoading}>
              Reject
            </Button>
          </Space>
        );
      case 'paused_for_approval':
        return (
          <Button type="primary" icon={<CheckOutlined />} onClick={() => approveAnalysisMutation()} loading={isApproving} disabled={isLoading}>
            Approve Analysis & Proceed to Content Generation
          </Button>
        );
      case 'validated':
        return (
          <Button type="primary" icon={<ExperimentOutlined />} onClick={() => generateContentMutation({ opportunityId, modelOverride: null, temperature: null })} loading={isGenerating} disabled={isLoading}>
            Generate Content
          </Button>
        );
      case 'failed':
      case 'rejected':
        return (
          <Button type="primary" icon={<RocketOutlined />} onClick={() => startWorkflowMutation()} loading={isStartingWorkflow} disabled={isLoading}>
            Rerun Workflow
          </Button>
        );
      default:
        return <Alert message="No actions available for the current status." type="info" showIcon />;
    }
  };

  return (
    <Card>
      <Space direction="vertical" style={{ width: '100%' }}>
        <Alert
          message="Next Step"
          description="This is the primary action to move this opportunity forward in the workflow."
          type="info"
          showIcon
        />
        {renderActions()}
      </Space>
    </Card>
  );
};

export default ActionCenter;
```

## File: src/pages/opportunity-detail-page/components/AdditionalInsights.jsx
```javascript
import React from 'react';
import { Card, Typography, List, Tag } from 'antd';

const { Title, Paragraph } = Typography;

const AdditionalInsights = ({ serpOverview }) => {
  return (
    <Card title="Additional Insights">
      {serpOverview?.discussion_snippets?.length > 0 && (
        <>
          <Title level={5}>Discussion Snippets</Title>
          <List
            dataSource={serpOverview.discussion_snippets}
            renderItem={(item) => <List.Item>{item}</List.Item>}
            size="small"
            bordered
            style={{ marginBottom: '24px' }}
          />
        </>
      )}
    </Card>
  );
};

export default AdditionalInsights;
```

## File: src/pages/opportunity-detail-page/components/ArticlePreview.jsx
```javascript
import React from 'react';
import { Card, Typography, Image, Alert } from 'antd';
import NoData from './NoData';

const { Title, Paragraph } = Typography;

const ArticlePreview = ({ aiContent, featuredImagePath }) => {
  if (!aiContent) {
    return <NoData description="No article content has been generated yet." />;
  }

  const { article_title, article_body_html } = aiContent;

  return (
    <Card>
      <Title level={2}>{article_title}</Title>
      {featuredImagePath ? (
        <div style={{ textAlign: 'center', marginBottom: '24px' }}>
          <Image
            width="50%"
            src={`/api/images/${featuredImagePath.split('/').pop()}`}
            alt={article_title}
          />
        </div>
      ) : (
        <NoData description="No featured image has been generated yet." />
      )}
      <div dangerouslySetInnerHTML={{ __html: article_body_html }} />
    </Card>
  );
};

export default ArticlePreview;
```

## File: src/pages/opportunity-detail-page/components/CompetitorBacklinks.jsx
```javascript
import React from 'react';
import { Card, Statistic, Row, Col, Tooltip } from 'antd';
import { LinkOutlined, TeamOutlined, RiseOutlined } from '@ant-design/icons';

const CompetitorBacklinks = ({ avgBacklinksInfo }) => {
  if (!avgBacklinksInfo) {
    return <Card title="Competitor Backlink Analysis">No data available.</Card>;
  }

  const { backlinks, referring_domains, main_domain_rank } = avgBacklinksInfo;

  return (
    <Card title="Competitor Backlink Analysis">
      <Row gutter={16}>
        <Col span={8}>
          <Tooltip title="The average number of backlinks for the top-ranking pages.">
            <Statistic title="Avg. Backlinks" value={backlinks} prefix={<LinkOutlined />} />
          </Tooltip>
        </Col>
        <Col span={8}>
          <Tooltip title="The average number of unique domains linking to the top-ranking pages.">
            <Statistic title="Avg. Referring Domains" value={referring_domains} prefix={<TeamOutlined />} />
          </Tooltip>
        </Col>
        <Col span={8}>
          <Tooltip title="The average Domain Rank (a measure of a website's authority) of the top-ranking pages.">
            <Statistic title="Avg. Domain Rank" value={main_domain_rank} prefix={<RiseOutlined />} />
          </Tooltip>
        </Col>
      </Row>
    </Card>
  );
};

export default CompetitorBacklinks;
```

## File: src/pages/opportunity-detail-page/components/ContentAuditCard.jsx
```javascript
import React from 'react';
import { Card, Typography, List, Tag, Progress } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';

const { Title, Text } = Typography;

const ContentAuditCard = ({ auditResults }) => {
  if (!auditResults) {
    return null;
  }

  const {
    flesch_kincaid_grade,
    readability_assessment,
    entity_coverage_score,
    missing_entities,
    publish_readiness_issues,
  } = auditResults;

  return (
    <Card title="Content Audit" style={{ marginTop: 24 }}>
      <Title level={5}>Readability</Title>
      <Text>{readability_assessment}</Text>
      <Text strong style={{ display: 'block', marginTop: 8 }}>
        Flesch-Kincaid Grade Level: {flesch_kincaid_grade.toFixed(1)}
      </Text>

      <Title level={5} style={{ marginTop: 16 }}>Entity Coverage</Title>
      <Progress percent={entity_coverage_score} />
      {missing_entities && missing_entities.length > 0 && (
        <>
          <Text strong style={{ display: 'block', marginTop: 8 }}>Missing Entities:</Text>
          <List
            dataSource={missing_entities}
            renderItem={(item) => (
              <List.Item>
                <CloseCircleOutlined style={{ color: 'red', marginRight: 8 }} />
                {item}
              </List.Item>
            )}
            size="small"
          />
        </>
      )}

      <Title level={5} style={{ marginTop: 16 }}>Publishing Readiness</Title>
      {publish_readiness_issues && publish_readiness_issues.length > 0 ? (
        <List
          dataSource={publish_readiness_issues}
          renderItem={(item) => (
            <List.Item>
              <CloseCircleOutlined style={{ color: 'red', marginRight: 8 }} />
              <Text>{item.issue}: {item.context}</Text>
            </List.Item>
          )}
          size="small"
        />
      ) : (
        <Space>
          <CheckCircleOutlined style={{ color: 'green' }} />
          <Text>No publishing readiness issues found.</Text>
        </Space>
      )}
    </Card>
  );
};

export default ContentAuditCard;
```

## File: src/pages/opportunity-detail-page/components/ContentBlueprint.jsx
```javascript
import React, { useState, useEffect } from 'react';
import { Card, Typography, List, Tag, Descriptions, Button, Tooltip, Select } from 'antd';
import { CopyOutlined, LinkOutlined, BulbOutlined, PlusOutlined } from '@ant-design/icons';
import { useNotifications } from '../../../context/NotificationContext';
import NoData from './NoData';

const { Title, Paragraph, Text } = Typography;
const { Option } = Select;

const ContentBlueprint = ({ blueprint, overrides, setOverrides }) => {
  const { showNotification } = useNotifications();
  const [paaToAdd, setPaaToAdd] = useState(null);

  if (!blueprint) {
    return <Card><Paragraph type="secondary">No content blueprint available.</Paragraph></Card>;
  }

  const { ai_content_brief, content_intelligence, recommended_strategy } = blueprint;
  const people_also_ask = blueprint.serp_overview?.people_also_ask || [];

  const handleCopyOutline = () => {
    const outline = overrides
      .map((item) => {
        const h3s = item.h3s.map((h3) => `  - ${h3}`).join('\n');
        return `${item.h2}\n${h3s}`;
      })
      .join('\n\n');
    navigator.clipboard.writeText(outline);
    showNotification('success', 'Copied to Clipboard', 'The article outline has been copied.');
  };

  const handleAddPaa = () => {
    if (!paaToAdd) return;

    const faqSectionIndex = overrides.findIndex(sec => sec.h2.toLowerCase().includes('frequently asked questions'));
    
    if (faqSectionIndex > -1) {
      const newStructure = [...overrides];
      newStructure[faqSectionIndex].h3s.push(paaToAdd);
      setOverrides(newStructure);
      showNotification('success', 'Question Added', `"${paaToAdd}" was added to the outline.`);
    } else {
      showNotification('warning', 'Section Not Found', 'Could not find a "Frequently Asked Questions" section to add this to.');
    }
    setPaaToAdd(null);
  };
  
  return (
    <Card title="AI Content Blueprint">
      <Descriptions bordered column={1} size="small" style={{ marginBottom: '24px' }}>
        <Descriptions.Item label="Target Audience">{ai_content_brief?.target_audience_persona || 'Not available'}</Descriptions.Item>
        <Descriptions.Item label="Primary Goal">{ai_content_brief?.primary_goal || 'Not available'}</Descriptions.Item>
        <Descriptions.Item label="Target Word Count">{ai_content_brief?.target_word_count || 'Not available'}</Descriptions.Item>
      </Descriptions>

      <Title level={5}>Dynamic SERP Instructions</Title>
      <List
        dataSource={ai_content_brief.dynamic_serp_instructions}
        renderItem={(item) => <List.Item><BulbOutlined style={{ marginRight: 8 }} />{item}</List.Item>}
        style={{ marginBottom: '24px' }}
        size="small"
      />

      <Title level={5}>Content Gaps & Unique Angles</Title>
      <List
        dataSource={content_intelligence.identified_content_gaps}
        renderItem={(item) => <List.Item>{item}</List.Item>}
        style={{ marginBottom: '24px' }}
      />

      <Title level={5}>Recommended Article Structure</Title>
      <div style={{ marginBottom: 16 }}>
        <Select
          showSearch
          placeholder="Select a 'People Also Ask' question to add to your outline"
          style={{ width: 'calc(100% - 120px)', marginRight: 8 }}
          onChange={value => setPaaToAdd(value)}
          value={paaToAdd}
        >
          {people_also_ask.map(q => <Option key={q} value={q}>{q}</Option>)}
        </Select>
        <Button icon={<PlusOutlined />} onClick={handleAddPaa} disabled={!paaToAdd}>Add</Button>
        <Button
          icon={<CopyOutlined />}
          onClick={handleCopyOutline}
          style={{ float: 'right' }}
        >
          Copy Outline
        </Button>
      </div>
      <List
        dataSource={overrides}
        renderItem={(item) => (
          <List.Item>
            <List.Item.Meta
              title={item.h2}
              description={
                <div style={{ paddingLeft: '20px' }}>
                  {item.h3s.map(h3 => <p key={h3} style={{ margin: '4px 0' }}>- {h3}</p>)}
                </div>
              }
            />
          </List.Item>
        )}
        style={{ marginBottom: '24px' }}
      />

      <Title level={5}>Key Entities to Mention</Title>
      <div style={{ marginBottom: '24px' }}>
        {content_intelligence.key_entities_from_competitors.map((entity) => (
          <Tag key={entity} style={{ margin: '4px' }}>{entity}</Tag>
        ))}
      </div>

      <Title level={5}>Focus Competitors</Title>
      <List
        dataSource={recommended_strategy.focus_competitors}
        renderItem={(item) => (
          <List.Item>
            <a href={item.url} target="_blank" rel="noopener noreferrer">
              <LinkOutlined style={{ marginRight: 8 }} />
              {item.title}
            </a>
          </List.Item>
        )}
        style={{ marginBottom: '24px' }}
        bordered
        size="small"
      />

      <Title level={5}>Internal Linking Suggestions</Title>
      {blueprint.internal_linking_suggestions && blueprint.internal_linking_suggestions.length > 0 ? (
        <List
          dataSource={blueprint.internal_linking_suggestions}
          renderItem={(item) => (
            <List.Item>
              <Tooltip title={`Link to: ${item.url}`}>
                <Text>Anchor Text: "{item.anchor_text}"</Text>
              </Tooltip>
            </List.Item>
          )}
          bordered
          size="small"
        />
      ) : (
        <NoData description="No internal linking suggestions were generated." />
      )}
    </Card>
  );
};

export default ContentBlueprint;
```

## File: src/pages/opportunity-detail-page/components/ErrorMessage.jsx
```javascript
import React from 'react';
import { Alert } from 'antd';

const ErrorMessage = ({ message }) => {
  if (!message || !(message.toLowerCase().includes('error') || message.toLowerCase().includes('failed'))) {
    return null;
  }

  return (
    <Alert
      message="Workflow Error"
      description={message}
      type="error"
      showIcon
      closable
    />
  );
};

export default ErrorMessage;
```

## File: src/pages/opportunity-detail-page/components/ExecutiveSummary.jsx
```javascript
import React from 'react';
import { Card, Typography } from 'antd';

const { Title, Paragraph } = Typography;

const ExecutiveSummary = ({ summary }) => {
  if (!summary) {
    return null;
  }

  return (
    <Card style={{ marginTop: 24 }}>
      <Title level={4}>Executive Summary</Title>
      <Paragraph>{summary}</Paragraph>
    </Card>
  );
};

export default ExecutiveSummary;
```

## File: src/pages/opportunity-detail-page/components/FactorsCard.jsx
```javascript
import React from 'react';
import { Card, Typography, List, Row, Col } from 'antd';
import { CheckCircleOutlined, CloseCircleOutlined } from '@ant-design/icons';
import NoData from './NoData';

const { Title } = Typography;

const FactorsCard = ({ positiveFactors, negativeFactors }) => {
  return (
    <Card style={{ marginTop: 24 }}>
      <Row gutter={16}>
        <Col span={12}>
          <Title level={5}>Positive Factors</Title>
          <List
            dataSource={positiveFactors}
            renderItem={(item) => (
              <List.Item>
                <CheckCircleOutlined style={{ color: 'green', marginRight: '8px' }} /> {item}
              </List.Item>
            )}
          />
        </Col>
        <Col span={12}>
          <Title level={5}>Negative Factors</Title>
          {negativeFactors && negativeFactors.length > 0 ? (
            <List
              dataSource={negativeFactors}
              renderItem={(item) => (
                <List.Item>
                  <CloseCircleOutlined style={{ color: 'red', marginRight: '8px' }} /> {item}
                </List.Item>
              )}
            />
          ) : (
            <NoData description="No negative factors identified." />
          )}
        </Col>
      </Row>
    </Card>
  );
};

export default FactorsCard;
```

## File: src/pages/opportunity-detail-page/components/FeaturedSnippetCard.jsx
```javascript
import React from 'react';
import { Card, Typography } from 'antd';
import { TrophyOutlined } from '@ant-design/icons';

const { Title, Paragraph } = Typography;

const FeaturedSnippetCard = ({ blueprint }) => {
  const featuredSnippet = blueprint?.serp_overview?.featured_snippet_content;

  if (!featuredSnippet) {
    return null; // Don't render the card if there's no snippet
  }

  return (
    <Card
      title={<span><TrophyOutlined style={{ marginRight: 8 }} /> Featured Snippet Opportunity</span>}
      bordered={false}
      style={{ backgroundColor: '#e6f7ff' }}
    >
      <Paragraph>
        The following content currently holds the featured snippet position. Your goal is to provide a better, more direct answer.
      </Paragraph>
      <Paragraph blockquote="true" style={{ fontStyle: 'italic' }}>
        {featuredSnippet}
      </Paragraph>
    </Card>
  );
};

export default FeaturedSnippetCard;
```

## File: src/pages/opportunity-detail-page/components/GrowthTrend.jsx
```javascript
import React from 'react';
import { Card, Statistic, Tooltip } from 'antd';
import { RiseOutlined } from '@ant-design/icons';

const GrowthTrend = ({ scoreBreakdown }) => {
  const growthTrend = scoreBreakdown?.growth_trend;

  if (!growthTrend) {
    return null;
  }

  return (
    <Card>
      <Tooltip title={growthTrend.breakdown['Growth Trend'].explanation}>
        <Statistic
          title="Year-over-Year Growth"
          value={growthTrend.breakdown['Growth Trend'].value}
          prefix={<RiseOutlined />}
          valueStyle={{ color: '#3f8600' }}
        />
      </Tooltip>
    </Card>
  );
};

export default GrowthTrend;
```

## File: src/pages/opportunity-detail-page/components/IntentAnalysis.jsx
```javascript
import React from 'react';
import { Card, Typography, Tag, Tooltip } from 'antd';
import { AimOutlined, DollarOutlined } from '@ant-design/icons';

const { Title, Text } = Typography;

const IntentAnalysis = ({ searchIntentInfo }) => {
  if (!searchIntentInfo) {
    return null;
  }

  const { main_intent, foreign_intent } = searchIntentInfo;

  const intentColor = {
    informational: 'blue',
    commercial: 'gold',
    transactional: 'green',
    navigational: 'purple',
  };

  return (
    <Card title="Search Intent Analysis">
      <Tooltip title="The primary reason a user is searching for this keyword.">
        <div>
          <Text strong>Main Intent: </Text>
          <Tag color={intentColor[main_intent] || 'default'} icon={<AimOutlined />}>
            {main_intent?.toUpperCase()}
          </Tag>
        </div>
      </Tooltip>
      {foreign_intent?.length > 0 && (
        <Tooltip title="Other potential intents this keyword might satisfy.">
          <div style={{ marginTop: '16px' }}>
            <Text strong>Secondary Intents: </Text>
            {foreign_intent.map(intent => (
              <Tag key={intent} color={intentColor[intent] || 'default'} icon={<DollarOutlined />}>
                {intent.toUpperCase()}
              </Tag>
            ))}
          </div>
        </Tooltip>
      )}
    </Card>
  );
};

export default IntentAnalysis;
```

## File: src/pages/opportunity-detail-page/components/KeywordMetrics.jsx
```javascript
import React from 'react';
import { Card, Statistic, Row, Col, Tooltip, Tag } from 'antd';
import { BarChartOutlined, DollarCircleOutlined, ThunderboltOutlined, InfoCircleOutlined } from '@ant-design/icons';
import { Line } from '@ant-design/plots';

const KeywordMetrics = ({ keywordInfo, keywordProperties }) => {
  if (!keywordInfo || !keywordProperties) {
    return <Card title="Keyword Metrics">No data available.</Card>;
  }

  const { search_volume, cpc, competition, monthly_searches, competition_level, low_top_of_page_bid, high_top_of_page_bid } = keywordInfo;
  const { keyword_difficulty } = keywordProperties;

  const chartData = monthly_searches?.map(item => ({
    date: `${item.year}-${item.month}`,
    volume: item.search_volume,
  }));

  const chartConfig = {
    data: chartData,
    xField: 'date',
    yField: 'volume',
    height: 200,
    point: {
      size: 5,
      shape: 'diamond',
    },
    tooltip: {
      formatter: (datum) => {
        return { name: 'Search Volume', value: datum.volume.toLocaleString() };
      },
    },
  };

  return (
    <Card title="Keyword Metrics">
      <Row gutter={[16, 24]}>
        <Col span={12}>
          <Tooltip title="The average number of times this keyword is searched for per month.">
            <Statistic title="Search Volume" value={search_volume} prefix={<BarChartOutlined />} />
          </Tooltip>
        </Col>
        <Col span={12}>
          <Tooltip title="The average cost per click for this keyword in paid search campaigns.">
            <Statistic title="CPC" value={cpc} prefix={<DollarCircleOutlined />} precision={2} />
          </Tooltip>
        </Col>
        <Col span={12}>
          <Tooltip title="The level of competition for this keyword in paid search campaigns, on a scale of 0 to 1.">
            <div>
              <Statistic title="Competition" value={competition} precision={2} />
              <Tag color={competition_level === 'LOW' ? 'green' : competition_level === 'MEDIUM' ? 'orange' : 'red'}>{competition_level}</Tag>
            </div>
          </Tooltip>
        </Col>
        <Col span={12}>
          <Tooltip title="An estimate of how difficult it would be to rank organically for this keyword, on a scale of 0 to 100.">
            <Statistic title="Keyword Difficulty" value={keyword_difficulty} prefix={<ThunderboltOutlined />} />
          </Tooltip>
        </Col>
        <Col span={12}>
          <Tooltip title="The lower range of what advertisers have historically paid for a top-of-page bid.">
            <Statistic title="Low Top of Page Bid" value={low_top_of_page_bid} precision={2} prefix="$" />
          </Tooltip>
        </Col>
        <Col span={12}>
          <Tooltip title="The higher range of what advertisers have historically paid for a top-of-page bid.">
            <Statistic title="High Top of Page Bid" value={high_top_of_page_bid} precision={2} prefix="$" />
          </Tooltip>
        </Col>
      </Row>
      <div style={{ marginTop: '24px' }}>
        {chartData && chartData.length > 0 ? (
          <Line {...chartConfig} />
        ) : (
          <div style={{ textAlign: 'center', padding: '20px' }}>
            <InfoCircleOutlined style={{ marginRight: '8px' }} />
            No monthly search volume data available to display a chart.
          </div>
        )}
      </div>
    </Card>
  );
};

export default KeywordMetrics;
```

## File: src/pages/opportunity-detail-page/components/MetaInfo.jsx
```javascript
import React from 'react';
import { Card, Descriptions, Tag } from 'antd';
import { InfoCircleOutlined, DollarCircleOutlined, HistoryOutlined } from '@ant-design/icons';
import { format } from 'date-fns';

const MetaInfo = ({ blueprint, lastWorkflowStep, dateProcessed }) => {
  const metadata = blueprint?.metadata;

  return (
    <Card title="Process Metadata" icon={<InfoCircleOutlined />}>
      <Descriptions column={1} size="small" variant="outlined">
        {metadata?.blueprint_version && (
          <Descriptions.Item label="Blueprint Version">
            <Tag>{metadata.blueprint_version}</Tag>
          </Descriptions.Item>
        )}
        {lastWorkflowStep && (
          <Descriptions.Item label="Last Workflow Step">
            <Tag color="blue">{lastWorkflowStep.replace(/_/g, ' ')}</Tag>
          </Descriptions.Item>
        )}
        {dateProcessed && (
          <Descriptions.Item label="Date Processed">
            <HistoryOutlined /> {format(new Date(dateProcessed), 'MMM d, yyyy HH:mm')}
          </Descriptions.Item>
        )}
        {metadata?.total_api_cost && (
          <Descriptions.Item label="Analysis API Cost">
            <DollarCircleOutlined /> ${metadata.total_api_cost.toFixed(4)}
          </Descriptions.Item>
        )}
      </Descriptions>
    </Card>
  );
};

export default MetaInfo;
```

## File: src/pages/opportunity-detail-page/components/NoData.jsx
```javascript
import React from 'react';
import { Empty } from 'antd';

const NoData = ({ description }) => {
  return (
    <div style={{ padding: '24px', textAlign: 'center' }}>
      <Empty
        image={Empty.PRESENTED_IMAGE_SIMPLE}
        description={description || 'No data available for this section.'}
      />
    </div>
  );
};

export default NoData;
```

## File: src/pages/opportunity-detail-page/components/OpportunityHeader.jsx
```javascript
import React from 'react';
import { Card, Tag, Statistic, Row, Col, Typography, Progress } from 'antd';
import { format } from 'date-fns';

const { Title, Text } = Typography;

const getStatusColor = (status) => {
  if (status.includes('approved') || status === 'validated') return 'success';
  if (status.includes('paused')) return 'warning';
  if (status.includes('failed')) return 'error';
  return 'processing';
};

const OpportunityHeader = ({ keyword, strategicScore, status, dateAdded, recommendation }) => {
  return (
    <Card style={{ borderRadius: '8px' }}>
      <Row align="middle" justify="space-between">
        <Col>
          <Title level={2} style={{ margin: 0 }}>{keyword}</Title>
          <Tag color={getStatusColor(status)} style={{ marginTop: 8 }}>
            {status.replace(/_/g, ' ').toUpperCase()}
          </Tag>
        </Col>
        <Col>
          <Row align="middle" gutter={32}>
            <Col>
              <Statistic title="Date Added" value={format(new Date(dateAdded), 'MMM d, yyyy')} />
            </Col>
            {recommendation && (
              <Col>
                <Tag color={recommendation === 'Proceed' ? 'success' : 'error'} style={{ fontSize: '1.2rem', padding: '10px' }}>
                  {recommendation}
                </Tag>
              </Col>
            )}
            <Col style={{ textAlign: 'center' }}>
              {typeof strategicScore === 'number' && (
                <>
                  <Progress
                    type="circle"
                    percent={strategicScore}
                    format={(percent) => `${percent.toFixed(1)}`}
                    strokeColor={{
                      '0%': '#B8E1FF',
                      '100%': '#3D76DD',
                    }}
                    size={80}
                  />
                  <Text style={{ display: 'block', marginTop: 8 }}>Strategic Score</Text>
                </>
              )}
            </Col>
          </Row>
        </Col>
      </Row>
    </Card>
  );
};

export default OpportunityHeader;
```

## File: src/pages/opportunity-detail-page/components/QualificationInfo.jsx
```javascript
import React from 'react';
import { Card, Typography, Tag } from 'antd';
import { CheckSquareOutlined } from '@ant-design/icons';

const { Text } = Typography;

const QualificationInfo = ({ status, reason }) => {
  if (!status) {
    return null;
  }

  return (
    <Card title="Initial Qualification">
      <Text strong>Status: </Text>
      <Tag color={status === 'review' ? 'orange' : 'default'}>{status.toUpperCase()}</Tag>
      <Text type="secondary" style={{ marginTop: '16px', display: 'block' }}>
        {reason}
      </Text>
    </Card>
  );
};

export default QualificationInfo;
```

## File: src/pages/opportunity-detail-page/components/RecommendedStrategyCard.jsx
```javascript
import React from 'react';
import { Card, Typography, Tag } from 'antd';
import { BulbOutlined } from '@ant-design/icons';

const { Title, Paragraph } = Typography;

const RecommendedStrategyCard = ({ strategy }) => {
  if (!strategy) {
    return null;
  }

  return (
    <Card style={{ marginTop: 24 }}>
      <Title level={5}><BulbOutlined /> Recommended Strategy</Title>
      <Paragraph strong>Content Format: <Tag color="purple">{strategy.content_format}</Tag></Paragraph>
      <Paragraph>{strategy.strategic_goal}</Paragraph>
    </Card>
  );
};

export default RecommendedStrategyCard;
```

## File: src/pages/opportunity-detail-page/components/SerpAnalysis.jsx
```javascript
import React from 'react';
import { Card, Table, Tag, List, Typography, Button, Statistic, Row, Col } from 'antd';
import {
  FileTextOutlined,
  VideoCameraOutlined,
  QuestionCircleOutlined,
  CommentOutlined,
  SearchOutlined,
  CopyOutlined,
  RobotOutlined,
  FileDoneOutlined,
  LinkOutlined,
  StarFilled
} from '@ant-design/icons';
import { useNotifications } from '../../../context/NotificationContext';

const { Title, Paragraph, Text } = Typography;

const SerpAnalysis = ({ blueprint }) => {
  const { showNotification } = useNotifications();

  if (!blueprint || !blueprint.serp_overview) {
    return <Card><Paragraph type="secondary">No SERP analysis available.</Paragraph></Card>;
  }

  const { top_organic_results, people_also_ask, related_searches, top_organic_sitelinks, serp_has_ai_overview, dominant_content_format } = blueprint.serp_overview;
  const { serp_item_types, se_results_count } = blueprint.winning_keyword.serp_info;

  const getSerpFeatureIcon = (item) => {
    if (item.includes('video')) return <VideoCameraOutlined />;
    if (item.includes('people_also_ask')) return <QuestionCircleOutlined />;
    if (item.includes('perspectives')) return <CommentOutlined />;
    if (item.includes('related_searches')) return <SearchOutlined />;
    return <FileTextOutlined />;
  };

  const handleCopyPaA = () => {
    navigator.clipboard.writeText(people_also_ask.join('\n'));
    showNotification('success', 'Copied to Clipboard', 'People Also Ask questions have been copied.');
  };

  const columns = [
    { title: 'Rank', dataIndex: 'rank', key: 'rank' },
    { title: 'Title', dataIndex: 'title', key: 'title', render: (text, record) => <a href={record.url} target="_blank" rel="noopener noreferrer">{text}</a> },
    { title: 'Domain', dataIndex: 'domain', key: 'domain' },
    { title: 'Page Type', dataIndex: 'page_type', key: 'page_type', render: (type) => <Tag>{type}</Tag> },
    { 
      title: 'Rating', 
      dataIndex: 'rating', 
      key: 'rating', 
      render: (rating) => rating ? <span><StarFilled style={{ color: '#fadb14' }} /> {rating.value} ({rating.votes_count})</span> : null 
    },
  ];

  const handleRelatedSearchClick = (term) => {
    // In a real app, you would likely navigate to the discovery page with this term
    console.log(`Starting a new discovery run for: ${term}`);
    showNotification('info', 'Discovery Run Started', `A new discovery run has been initiated for "${term}".`);
  };

  return (
    <Card title="SERP Analysis">
      <Row gutter={16} style={{ marginBottom: 24 }}>
        <Col span={8}>
          <Statistic title="Total Search Results" value={se_results_count} />
        </Col>
        <Col span={8}>
          <Statistic title="AI Overview in SERP" value={serp_has_ai_overview ? 'Yes' : 'No'} prefix={<RobotOutlined />} />
        </Col>
        <Col span={8}>
           <Statistic title="Dominant Content Format" value={dominant_content_format} prefix={<FileDoneOutlined />} />
        </Col>
      </Row>

      <Title level={5}>SERP Features Present</Title>
      <List
        dataSource={serp_item_types}
        renderItem={(item) => <List.Item><Tag icon={getSerpFeatureIcon(item)}>{item.replace(/_/g, ' ')}</Tag></List.Item>}
        grid={{ gutter: 16, column: 4 }}
        style={{ marginBottom: 24 }}
      />

      <Title level={5}>People Also Ask</Title>
      <Button icon={<CopyOutlined />} onClick={handleCopyPaA} style={{ float: 'right' }}>Copy</Button>
      <List dataSource={people_also_ask} renderItem={(item) => <List.Item>{item}</List.Item>} style={{ marginBottom: 24 }} />

      <Title level={5}>Related Searches</Title>
      <div style={{ marginBottom: 24 }}>
        {related_searches.map(term => (
          <Tag 
            icon={<SearchOutlined />} 
            key={term} 
            style={{ margin: 4, cursor: 'pointer' }}
            onClick={() => handleRelatedSearchClick(term)}
          >
            {term}
          </Tag>
        ))}
      </div>
      
      {top_organic_sitelinks?.length > 0 && <>
        <Title level={5}>Top Organic Sitelinks</Title>
        <List dataSource={top_organic_sitelinks} renderItem={(item) => <List.Item><LinkOutlined /> {item}</List.Item>} style={{ marginBottom: 24 }} />
      </>}

      <Title level={5}>Top 10 Organic Results</Title>
      <Table columns={columns} dataSource={top_organic_results} rowKey="url" pagination={false} size="small" />
    </Card>
  );
};

export default SerpAnalysis;
```

## File: src/pages/opportunity-detail-page/components/SerpVitals.jsx
```javascript
import React from 'react';
import { Card, Row, Col, Statistic, Tooltip } from 'antd';
import { CloudSyncOutlined, AlertOutlined } from '@ant-design/icons';

const SerpVitals = ({ scoreBreakdown }) => {
  const volatility = scoreBreakdown?.serp_volatility;
  const crowding = scoreBreakdown?.serp_crowding;

  if (!volatility && !crowding) {
    return null;
  }

  return (
    <Card title="SERP Vitals">
      <Row gutter={16}>
        {volatility && (
          <Col span={12}>
            <Tooltip title={volatility.breakdown['SERP Stability'].explanation}>
              <Statistic 
                title="SERP Stability" 
                value={volatility.breakdown['SERP Stability'].value} 
                prefix={<CloudSyncOutlined />} 
              />
            </Tooltip>
          </Col>
        )}
        {crowding && (
          <Col span={12}>
            <Tooltip title={crowding.breakdown['SERP Crowding'].explanation}>
              <Statistic 
                title="SERP Crowding" 
                value={`${crowding.breakdown['SERP Crowding'].value} Features`}
                prefix={<AlertOutlined />} 
              />
            </Tooltip>
          </Col>
        )}
      </Row>
    </Card>
  );
};

export default SerpVitals;
```

## File: src/pages/opportunity-detail-page/components/SocialMediaTab.jsx
```javascript
import React from 'react';
import { Card, Typography, List, Button, Tooltip } from 'antd';
import { CopyOutlined } from '@ant-design/icons';
import { useNotifications } from '../../../context/NotificationContext';

const { Title, Paragraph } = Typography;

const SocialMediaTab = ({ socialMediaPosts }) => {
  const { showNotification } = useNotifications();

  if (!socialMediaPosts || socialMediaPosts.length === 0) {
    return <Card><Paragraph>No social media posts have been generated yet.</Paragraph></Card>;
  }

  const handleCopy = (text) => {
    navigator.clipboard.writeText(text);
    showNotification('success', 'Copied to Clipboard', 'The post content has been copied.');
  };

  return (
    <List
      grid={{ gutter: 16, column: 2 }}
      dataSource={socialMediaPosts}
      renderItem={(post) => (
        <List.Item>
          <Card title={post.platform}>
            <Paragraph>{post.content}</Paragraph>
            <Tooltip title="Copy Post">
              <Button
                icon={<CopyOutlined />}
                onClick={() => handleCopy(post.content)}
              />
            </Tooltip>
          </Card>
        </List.Item>
      )}
    />
  );
};

export default SocialMediaTab;
```

## File: src/pages/opportunity-detail-page/components/StrategicNotes.jsx
```javascript
import React from 'react';
import { Alert } from 'antd';
import { BulbOutlined } from '@ant-design/icons';

const StrategicNotes = ({ notes }) => {
  if (!notes) {
    return null;
  }

  return (
    <Alert
      message="Strategic Note from AI Analysis"
      description={notes}
      type="warning"
      showIcon
      icon={<BulbOutlined />}
    />
  );
};

export default StrategicNotes;
```

## File: src/pages/opportunity-detail-page/components/StrategicScoreBreakdown.jsx
```javascript
import React from 'react';
import { Card, Typography, Tooltip, Progress, List, Tag } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';

const { Title, Text, Paragraph } = Typography;

const scoreCategoryMapping = {
  'Ranking & Competition': ['ease_of_ranking', 'competitor_weakness', 'competitor_performance'],
  'Traffic & Commercial Value': ['traffic_potential', 'commercial_intent', 'growth_trend', 'volume_volatility'],
  'SERP Environment': ['serp_features', 'serp_volatility', 'serp_crowding', 'serp_threat', 'serp_freshness'],
  'Keyword Profile': ['keyword_structure'],
};

const friendlyExplanations = {
  ease_of_ranking: "This score assesses the overall difficulty of ranking on the first page of Google for this keyword. It's a composite metric that considers the authority of competing websites, the keyword's inherent difficulty, and the number of competing pages. A higher score means we've identified a path of lower resistance.",
  competitor_weakness: "We analyze the top-ranking pages to find their weak spots. This score is higher if competitors have low domain authority, few backlinks, or other vulnerabilities that we can strategically exploit to outrank them.",
  competitor_performance: "This score evaluates the technical performance of competing websites, such as their loading speed and mobile-friendliness. Slower or poorly optimized competitor sites present a clear opportunity, as search engines penalize them, making it easier for us to rank higher with a technically superior page.",
  traffic_potential: "This score estimates the potential traffic this keyword could generate. It's not just about raw search volume; it also considers the keyword's cost-per-click (CPC) value, indicating its commercial worth. A high score suggests the keyword can attract a valuable audience.",
  commercial_intent: "We analyze the language of the keyword and the types of ads on the search results page to determine the user's intent. A high score indicates that the user is likely looking to make a purchase or engage a service, making the traffic more valuable.",
  growth_trend: "This score reflects the keyword's popularity over time. We analyze search data from the past year to identify upward trends. A high score means the keyword is becoming more popular, representing a growing area of interest and a sustainable source of future traffic.",
  volume_volatility: "This score measures the stability of the keyword's search volume. A low score indicates high volatility (e.g., a seasonal trend), while a high score suggests a stable, consistent search volume, making it a more reliable target for long-term content strategy.",
  serp_features: "This score identifies opportunities within the Search Engine Results Page (SERP) itself. We look for features like 'Featured Snippets,' 'People Also Ask' boxes, and video carousels. A high score means there are multiple ways to appear on the first page beyond the standard blue links.",
  serp_volatility: "This score measures how frequently the rankings for this keyword change. A highly volatile SERP, where rankings fluctuate often, can be an opportunity to quickly gain a foothold, as it indicates that search engines are still trying to determine the best results.",
  serp_crowding: "This score assesses how 'crowded' the search results page is with non-organic results like ads, image packs, and shopping results. A lower score means the page is very crowded, which can push organic results further down the page and reduce their visibility.",
  serp_threat: "This score identifies the presence of dominant, high-authority domains (like Wikipedia, government sites, or major news outlets) that are extremely difficult to outrank. A high score indicates the absence of such threats, making it a more level playing field.",
  serp_freshness: "This score evaluates the age of the content currently ranking on the first page. If the top results are several years old, it signals a 'freshness' opportunity, where new, up-to-date content is likely to be favored by search engines.",
  keyword_structure: "This score analyzes the composition of the keyword itself. Longer, more specific keywords (long-tail keywords) are often less competitive and signal a more specific user intent, making them easier to rank for. A high score is awarded to these types of keywords.",
};

const StrategicScoreBreakdown = ({ scoreBreakdown }) => {
  if (!scoreBreakdown) {
    return null;
  }

  const getScoreColor = (score) => {
    if (score > 70) return '#52c41a'; // green
    if (score > 40) return '#faad14'; // orange
    return '#f5222d'; // red
  };

  return (
    <Card title="Strategic Score Analysis" style={{ marginTop: 24 }}>
      <Paragraph type="secondary">
        This analysis breaks down the main factors contributing to the overall Strategic Score. Each factor is scored from 0-100, where a higher score indicates a better opportunity.
      </Paragraph>
      {Object.entries(scoreCategoryMapping).map(([category, keys]) => (
        <div key={category}>
          <Title level={4} style={{ marginTop: 24, marginBottom: 16 }}>{category}</Title>
          <List
            itemLayout="vertical"
            dataSource={keys.map(key => ({ key, ...scoreBreakdown[key] })).filter(item => item.name)}
            renderItem={(factor) => (
              <List.Item key={factor.key}>
                <List.Item.Meta
                  title={
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                      <span>
                        {factor.name}
                        <Tooltip title={friendlyExplanations[factor.key]}>
                          <InfoCircleOutlined style={{ marginLeft: 8, color: '#888' }} />
                        </Tooltip>
                      </span>
                      <Tag color={getScoreColor(factor.score)} style={{ fontSize: '1rem', padding: '4px 8px' }}>
                        {factor.score.toFixed(1)}
                      </Tag>
                    </div>
                  }
                  description={
                    <div>
                      <Progress
                        percent={factor.score}
                        showInfo={false}
                        strokeColor={getScoreColor(factor.score)}
                        style={{ marginBottom: 8 }}
                      />
                      {factor.breakdown.message ? (
                        <Text type="secondary">{factor.breakdown.message}</Text>
                      ) : (
                        <ul style={{ paddingLeft: 20, margin: 0 }}>
                          {Object.entries(factor.breakdown).map(([key, value]) => (
                            <li key={key}>
                              <Text strong>{key}:</Text> {value.value} - <Text type="secondary">{value.explanation}</Text>
                            </li>
                          ))}
                        </ul>
                      )}
                    </div>
                  }
                />
              </List.Item>
            )}
          />
        </div>
      ))}
    </Card>
  );
};

export default StrategicScoreBreakdown;
```

## File: src/pages/opportunity-detail-page/components/VerdictCard.jsx
```javascript
import React from 'react';
import { Card, Typography, Tag } from 'antd';

const { Title, Paragraph } = Typography;

const VerdictCard = ({ recommendation, confidenceScore }) => {
  if (!recommendation) {
    return null;
  }

  return (
    <Card style={{ marginTop: 24 }}>
      <Title level={5}>The Verdict</Title>
      <Tag color={recommendation === 'Proceed' ? 'success' : 'error'} style={{ fontSize: '1.2rem', padding: '10px' }}>
        {recommendation}
      </Tag>
      <Paragraph style={{ marginTop: '10px' }}>Confidence: {confidenceScore.toFixed(1)}%</Paragraph>
    </Card>
  );
};

export default VerdictCard;
```

## File: src/pages/opportunity-detail-page/components/WorkflowStatusAlert.jsx
```javascript
import React from 'react';
import { Alert } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';

const WorkflowStatusAlert = ({ status, message }) => {
  // Only show for specific, non-error statuses that have a message
  if (status !== 'paused_for_approval' || !message) {
    return null;
  }

  // Don't show if the message looks like an error
  if (message.toLowerCase().includes('error') || message.toLowerCase().includes('failed')) {
      return null;
  }

  return (
    <Alert
      message="Current Status"
      description={message}
      type="info"
      showIcon
      icon={<InfoCircleOutlined />}
    />
  );
};

export default WorkflowStatusAlert;
```

## File: src/pages/opportunity-detail-page/components/WorkflowTracker.jsx
```javascript
import React, { useEffect, useState } from 'react';
import { Card, Steps, Spin, Alert, Button } from 'antd';
import { useQuery, useQueryClient } from 'react-query';
import { useNavigate } from 'react-router-dom';
import { getJobStatus } from '../../../services/jobsService';
import { CheckCircleOutlined } from '@ant-design/icons';

const { Step } = Steps;

const IN_PROGRESS_STATUSES = ['processing', 'running', 'in_progress', 'pending', 'refresh_started'];

const WorkflowTracker = ({ opportunity }) => {
  const { latest_job_id, status, error_message } = opportunity;
  const navigate = useNavigate();
  const queryClient = useQueryClient();

  const { data: jobStatus, isLoading: isLoadingStatus } = useQuery(
    ['jobStatus', latest_job_id],
    () => getJobStatus(latest_job_id),
    {
      enabled: !!latest_job_id && (!jobStatus || (jobStatus.status !== 'completed' && jobStatus.status !== 'failed')),
      refetchInterval: 3000, // Poll every 3 seconds for faster updates
      onSuccess: (data) => {
        if (data?.status === 'completed' || data?.status === 'failed' || data?.status === 'paused') {
          // Invalidate queries to refetch the main opportunity data for the page
          queryClient.invalidateQueries(['opportunity', opportunity.id]);
        }
        
        if (data?.status === 'completed' && data.result?.redirect_url) {
          setTimeout(() => {
            navigate(data.result.redirect_url);
          }, 1500); // Delay for user to see the final success state
        }
      },
    }
  );

  const progressLog = jobStatus?.progress_log || [];
  const currentStepIndex = progressLog.length > 0 ? progressLog.length - 1 : 0;

  // Don't render anything if there's no job or the workflow is in a non-terminal, non-processing state
  if (!latest_job_id || (!IN_PROGRESS_STATUSES.includes(status) && status !== 'failed' && jobStatus?.status !== 'completed')) {
    return null;
  }

  const isJobRunning = jobStatus?.status === 'running' || jobStatus?.status === 'pending';

  return (
    <Card title="Workflow Status" style={{ marginTop: 24 }}>
      {isLoadingStatus && !jobStatus && <Spin tip="Initializing workflow status..." />}
      
      {progressLog.length > 0 && (
        <Steps direction="vertical" current={currentStepIndex}>
          {progressLog.map((log, index) => (
            <Step 
              key={index} 
              title={log.step} 
              description={log.message} 
              icon={isJobRunning && index === currentStepIndex ? <Spin /> : null}
            />
          ))}
        </Steps>
      )}

      {jobStatus?.status === 'completed' && (
        <Alert
          message="Workflow Completed"
          description={jobStatus.result?.message || 'The workflow finished successfully.'}
          type="success"
          showIcon
          icon={<CheckCircleOutlined />}
          action={
            jobStatus.result?.redirect_url && (
              <Button size="small" type="primary" onClick={() => navigate(jobStatus.result.redirect_url)}>
                Go to Results
              </Button>
            )
          }
        />
      )}

      {jobStatus?.status === 'failed' && (
        <Alert
          message="Workflow Failed"
          description={jobStatus.error || error_message || 'An unknown error occurred.'}
          type="error"
          showIcon
        />
      )}
    </Card>
  );
};

export default WorkflowTracker;
```

## File: src/pages/opportunity-detail-page/hooks/useOpportunityData.js
```javascript
import { useQuery } from 'react-query';
import { getOpportunityById } from '../../../services/opportunitiesService';

export const useOpportunityData = (opportunityId) => {
  const id = parseInt(opportunityId);
  const { data, isLoading, isError, error, refetch } = useQuery(
    ['opportunity', id],
    () => getOpportunityById(id),
    {
      enabled: !!id,
      staleTime: 5 * 60 * 1000, // 5 minutes
      cacheTime: 10 * 60 * 1000, // 10 minutes
    }
  );

  return { opportunity: data, isLoading, isError, error, refetch };
};
```

## File: src/pages/opportunity-detail-page/index.jsx
```javascript
import React, { useState, useEffect } from 'react';
import { useParams } from 'react-router-dom';
import { Layout, Spin, Alert, Row, Col, Tabs } from 'antd';
import { useOpportunityData } from './hooks/useOpportunityData';
import OpportunityHeader from './components/OpportunityHeader';
import ActionCenter from './components/ActionCenter';
import ExecutiveSummary from './components/ExecutiveSummary';
import KeywordMetrics from './components/KeywordMetrics';
import StrategicScoreBreakdown from './components/StrategicScoreBreakdown';
import SerpAnalysis from './components/SerpAnalysis';
import ContentBlueprint from './components/ContentBlueprint';
import ArticlePreview from './components/ArticlePreview';
import ContentAuditCard from './components/ContentAuditCard';
import SocialMediaTab from './components/SocialMediaTab';
import VerdictCard from './components/VerdictCard';
import FactorsCard from './components/FactorsCard';
import RecommendedStrategyCard from './components/RecommendedStrategyCard';
import StrategicNotes from './components/StrategicNotes';
import CompetitorBacklinks from './components/CompetitorBacklinks';
import IntentAnalysis from './components/IntentAnalysis';
import SerpVitals from './components/SerpVitals';
import GrowthTrend from './components/GrowthTrend';

import WorkflowTracker from './components/WorkflowTracker';

const { TabPane } = Tabs;

const OpportunityDetailPageV2 = () => {
  const { opportunityId } = useParams();
  const { opportunity, isLoading, isError, error, refetch } = useOpportunityData(opportunityId);
  const [blueprintOverrides, setBlueprintOverrides] = useState(null);

  useEffect(() => {
    if (opportunity?.blueprint?.content_intelligence?.article_structure) {
      setBlueprintOverrides(opportunity.blueprint.content_intelligence.article_structure);
    }
  }, [opportunity]);

  if (isLoading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Spin tip="Loading opportunity..." size="large" />
      </div>
    );
  }

  if (isError) {
    return <Alert message="Error" description={error.message} type="error" showIcon />;
  }

  if (!opportunity) {
    return null;
  }

  const { blueprint, ai_content, social_media_posts_json, score_breakdown, full_data } = opportunity;

  return (
    <Layout style={{ padding: '24px', background: '#f0f2f5' }}>
      <OpportunityHeader
        keyword={opportunity.keyword}
        strategicScore={opportunity.strategic_score}
        status={opportunity.status}
        dateAdded={opportunity.date_added}
        recommendation={blueprint?.final_qualification_assessment?.recommendation}
      />
      <ActionCenter 
        status={opportunity.status} 
        opportunityId={opportunity.id} 
        overrides={blueprintOverrides} 
        refetch={refetch}
        style={{ marginTop: 24, marginBottom: 24 }}
      />
      <WorkflowTracker opportunity={opportunity} />
      <Tabs defaultActiveKey="1">
        <TabPane tab="Overview" key="1">
          <Row gutter={[24, 24]}>
            <Col xs={24} lg={8}>
              <VerdictCard 
                recommendation={blueprint?.final_qualification_assessment?.recommendation}
                confidenceScore={blueprint?.final_qualification_assessment?.confidence_score}
              />
              <RecommendedStrategyCard strategy={blueprint?.recommended_strategy} />
              <KeywordMetrics 
                keywordInfo={opportunity.keyword_info} 
                keywordProperties={opportunity.keyword_properties}
              />
              <IntentAnalysis searchIntentInfo={opportunity.search_intent_info} />
              <GrowthTrend scoreBreakdown={score_breakdown} />
            </Col>
            <Col xs={24} lg={16}>
              <StrategicNotes notes={blueprint?.analysis_notes} />
              <FactorsCard 
                positiveFactors={blueprint?.final_qualification_assessment?.positive_factors}
                negativeFactors={blueprint?.final_qualification_assessment?.negative_factors}
              />
              <ExecutiveSummary summary={blueprint?.executive_summary} />
              <StrategicScoreBreakdown scoreBreakdown={score_breakdown} />
              <CompetitorBacklinks avgBacklinksInfo={full_data?.avg_backlinks_info} />
              <SerpVitals scoreBreakdown={score_breakdown} />
            </Col>
          </Row>
        </TabPane>
        <TabPane tab="SERP Analysis" key="2">
          <SerpAnalysis blueprint={blueprint} />
        </TabPane>
        <TabPane tab="Content Blueprint" key="3">
          <ContentBlueprint
            blueprint={blueprint}
            overrides={blueprintOverrides}
            setOverrides={setBlueprintOverrides}
          />
        </TabPane>
        <TabPane tab="Publishing" key="4">
          <Tabs defaultActiveKey="article">
            <TabPane tab="Article" key="article">
              <ArticlePreview
                aiContent={ai_content}
                featuredImagePath={opportunity.featured_image_local_path}
              />
            </TabPane>
            <TabPane tab="Social Media" key="social">
              <SocialMediaTab socialMediaPosts={social_media_posts_json} />
            </TabPane>
          </Tabs>
        </TabPane>
        <TabPane tab="Audit" key="5">
          <ContentAuditCard auditResults={ai_content?.audit_results} />
        </TabPane>
      </Tabs>
    </Layout>
  );
};

export default OpportunityDetailPageV2;
```

## File: src/pages/RunDetailsPage/RunDetailsPage.jsx
```javascript
import React from 'react';
import { useParams, Link } from 'react-router-dom';
import { useQuery } from 'react-query';
import { Layout, Spin, Alert, Typography, Progress, Card, Descriptions, Tag, Button } from 'antd';
import { ArrowLeftOutlined } from '@ant-design/icons';
import { getDiscoveryRunById } from '../../services/discoveryService'; // Adjust import path as needed
// import OpportunityTable from '../../components/OpportunityTable'; // Assuming a reusable table component exists

const { Content } = Layout;
const { Title, Paragraph } = Typography;

const RunDetailsPage = () => {
  const { runId } = useParams();

  const { data: run, isLoading, isError, error } = useQuery(
    ['discoveryRun', runId],
    () => getDiscoveryRunById(runId),
    {
      // Poll for updates every 5 seconds if the run is still in progress
      refetchInterval: (data) => {
        const inProgress = data?.status === 'PENDING' || data?.status === 'IN_PROGRESS';
        return inProgress ? 5000 : false;
      },
      refetchOnWindowFocus: false,
    }
  );

  if (isLoading) {
    return <Spin tip="Loading run details..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (isError) {
    return <Alert message="Error" description={error.message} type="error" showIcon />;
  }

  const getStatusTag = (status) => {
    switch (status) {
      case 'COMPLETED': return <Tag color="success">Completed</Tag>;
      case 'FAILED': return <Tag color="error">Failed</Tag>;
      case 'IN_PROGRESS': return <Tag color="processing">In Progress</Tag>;
      case 'PENDING': return <Tag color="gold">Pending</Tag>;
      default: return <Tag>{status}</Tag>;
    }
  };

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Button type="link" icon={<ArrowLeftOutlined />} style={{ marginBottom: '16px', paddingLeft: 0 }}>
          <Link to="/discovery">Back to Discovery Hub</Link>
        </Button>
        <Title level={2}>Discovery Run Details</Title>
        <Card style={{ marginBottom: '24px' }}>
          <Descriptions title="Run Summary" bordered>
            <Descriptions.Item label="Run ID">{run.id}</Descriptions.Item>
            <Descriptions.Item label="Status">{getStatusTag(run.status)}</Descriptions.Item>
            <Descriptions.Item label="Seed Keyword">{run.parameters?.seed_keywords?.join(', ')}</Descriptions.Item>
            <Descriptions.Item label="Created At">{new Date(run.created_at).toLocaleString()}</Descriptions.Item>
          </Descriptions>
          {run.status === 'IN_PROGRESS' && (
            <div style={{ marginTop: '16px' }}>
              <Paragraph>{run.progress_message || 'Processing...'}</Paragraph>
              <Progress percent={run.progress_percent || 0} />
            </div>
          )}
        </Card>

        {run.status === 'COMPLETED' && (
          <Card title="Discovered Opportunities">
            {/* Assuming you have a component to display opportunities */}
            {/* <OpportunityTable opportunities={run.opportunities} /> */}
          </Card>
        )}

        {run.status === 'FAILED' && (
          <Alert message="Run Failed" description={run.error_message || 'An unknown error occurred.'} type="error" showIcon />
        )}
      </Content>
    </Layout>
  );
};

export default RunDetailsPage;
```

## File: src/pages/Settings/tabs/AiContentSettingsTab.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Form, Input, InputNumber, Select, Switch, Slider, Typography, Row, Col, Divider, Tooltip, Alert, Space } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';
import PromptTemplateEditor from '../../../components/PromptTemplateEditor'; // NEW

const { Title, Text } = Typography;
const { Option } = Select;

const AiContentSettingsTab = ({ settings, form }) => {
  const contentModel = Form.useWatch('ai_content_model', form); // Watch for changes in the AI content model

  return (
    <>
      <Title level={5}>AI Model & Generation</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="ai_content_model" label="AI Content Generation Model">
            <Select style={{ width: '100%' }}>
              <Option value="gpt-4o">GPT-4o (Recommended)</Option>
              <Option value="gpt-4-turbo">GPT-4 Turbo</Option>
              <Option value="gpt-3.5-turbo">GPT-3.5 Turbo (Cost-Effective)</Option>
            </Select>
          </Form.Item>
          {contentModel === 'gpt-3.5-turbo' && (
            <Alert
              message="Cost-Effective Model Selected"
              description="GPT-3.5 Turbo is cheaper but may require more prompt engineering for quality."
              type="info"
              showIcon
              style={{ marginBottom: '16px' }}
            />
          )}
        </Col>
        <Col span={12}>
          <Form.Item name="ai_generation_temperature" label="AI Creativity (Temperature)">
            <Slider min={0.0} max={1.0} step={0.01} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="expert_persona" label="AI Writer Persona">
            <Input placeholder="e.g., a certified financial planner with 15 years of experience" />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="recommended_word_count_multiplier" label="Word Count Multiplier">
            <InputNumber min={0.5} max={3.0} step={0.1} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_completion_tokens_for_generation" label="Max Output Tokens">
            <InputNumber min={1000} max={32000} step={1000} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_words_for_ai_analysis" label="Max Words for AI Analysis">
            <InputNumber min={500} max={5000} step={100} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
      </Row>

      <Divider />

      <Title level={5}>Image Generation</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="use_pexels_first" label="Use Pexels for Images" valuePropName="checked">
            <Switch checkedChildren="Enabled" unCheckedChildren="Disabled" />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="num_in_article_images" label="Number of In-Article Images">
            <InputNumber min={0} max={5} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="overlay_text_enabled" label="Add Text Overlay to Images" valuePropName="checked">
            <Switch checkedChildren="Enabled" unCheckedChildren="Disabled" />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="overlay_text_color" label="Overlay Text Color">
            <Input type="color" style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="overlay_background_color" label="Overlay Background Color">
            <Input type="color" style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="overlay_font_size" label="Overlay Font Size">
            <InputNumber min={10} max={60} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="overlay_position" label="Overlay Position">
            <Select style={{ width: '100%' }}>
              <Option value="top_left">Top Left</Option>
              <Option value="top_center">Top Center</Option>
              <Option value="top_right">Top Right</Option>
              <Option value="bottom_left">Bottom Left</Option>
              <Option value="bottom_center">Bottom Center</Option>
              <Option value="bottom_right">Bottom Right</Option>
              <Option value="center">Center</Option>
            </Select>
          </Form.Item>
        </Col>
      </Row>

      <Divider />

      <Title level={5}>Custom AI Prompt Template</Title>
      <Form.Item 
        name="custom_prompt_template" 
        label={
          <Space>
            Edit your base prompt for the AI content generator.
            <Tooltip title="This template guides the AI's writing. Use available placeholders for dynamic data.">
              <InfoCircleOutlined />
            </Tooltip>
          </Space>
        }
        style={{ marginBottom: 0 }}
      >
        <PromptTemplateEditor disabled={false} />
      </Form.Item>
    </>
  );
};

export default AiContentSettingsTab;
```

## File: src/pages/Settings/tabs/DiscoverySettingsTab.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Form, Input, InputNumber, Select, Switch, Checkbox, Slider, Typography, Row, Col, Divider, Tooltip, Space } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';

const { Title, Text } = Typography;
const { Option } = Select;

const DiscoverySettingsTab = ({ settings, form }) => {
  return (
    <>
      <Title level={5}>General Discovery Parameters</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="min_search_volume" label="Minimum Search Volume">
            <InputNumber min={0} max={100000} step={10} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_keyword_difficulty" label="Maximum Keyword Difficulty">
            <InputNumber min={0} max={100} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="min_keyword_word_count" label="Minimum Keyword Word Count">
            <InputNumber min={1} max={20} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_keyword_word_count" label="Maximum Keyword Word Count">
            <InputNumber min={1} max={20} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_max_pages" label="Max API Pages to Fetch">
            <InputNumber min={1} max={100} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_related_depth" label="Related Keywords Depth">
            <Slider min={0} max={4} />
          </Form.Item>
        </Col>
        <Col span={24}>
          <Form.Item name="discovery_strategies" label="Discovery Strategies">
            <Checkbox.Group
              options={[
                { label: 'Keyword Ideas (Category-based)', value: 'Keyword Ideas' },
                { label: 'Keyword Suggestions (Phrase-based)', value: 'Keyword Suggestions' },
                { label: 'Related Keywords (SERP-based)', value: 'Related Keywords' },
              ]}
            />
          </Form.Item>
        </Col>
      </Row>

      <Divider />

      <Title level={5}>Advanced Filtering & Ordering</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="closely_variants" label="Search Mode (Keyword Ideas)" valuePropName="checked">
            <Switch checkedChildren="Phrase Match" unCheckedChildren="Broad Match" />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_ignore_synonyms" label="Ignore Synonyms" valuePropName="checked">
            <Switch />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_replace_with_core_keyword" label="Replace with Core Keyword" valuePropName="checked">
            <Switch />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="min_cpc_filter" label="Minimum CPC ($)">
            <InputNumber min={0.0} step={0.1} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_cpc_filter" label="Maximum CPC ($)">
            <InputNumber min={0.0} step={0.1} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="min_competition" label="Minimum Competition (0-1)">
            <InputNumber min={0.0} max={1.0} step={0.01} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_competition" label="Maximum Competition (0-1)">
            <InputNumber min={0.0} max={1.0} step={0.01} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_competition_level" label="Max Competition Level">
            <Select style={{ width: '100%' }}>
              <Option value="LOW">LOW</Option>
              <Option value="MEDIUM">MEDIUM</Option>
              <Option value="HIGH">HIGH</Option>
            </Select>
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_order_by_field" label="Order Results By">
            <Select style={{ width: '100%' }}>
              <Option value="keyword_info.search_volume">Search Volume</Option>
              <Option value="keyword_properties.keyword_difficulty">Keyword Difficulty</Option>
              <Option value="keyword_info.cpc">CPC</Option>
              <Option value="keyword_info.competition">Competition</Option>
            </Select>
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="discovery_order_by_direction" label="Order Direction">
            <Select style={{ width: '100%' }}>
              <Option value="desc">Descending</Option>
              <Option value="asc">Ascending</Option>
            </Select>
          </Form.Item>
        </Col>
        <Col span={24}>
          <Form.Item 
            name="search_phrase_regex" 
            label={
              <Space>
                Keyword Regex Filter
                <Tooltip title="Use regular expressions to filter keywords (e.g., ^how to.*$)">
                  <InfoCircleOutlined />
                </Tooltip>
              </Space>
            }
          >
            <Input placeholder="e.g., ^best.*reviews$" />
          </Form.Item>
        </Col>
      </Row>

      <Divider />

      <Title level={5}>Intent & Qualification</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="enforce_intent_filter" label="Enforce Intent Filter" valuePropName="checked">
            <Switch />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="allowed_intents" label="Allowed Intents">
            <Select mode="multiple" style={{ width: '100%' }}>
              <Option value="informational">Informational</Option>
              <Option value="commercial">Commercial</Option>
              <Option value="transactional">Transactional</Option>
              <Option value="navigational">Navigational</Option>
            </Select>
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="prohibited_intents" label="Prohibited Secondary Intents">
            <Select mode="multiple" style={{ width: '100%' }}>
              <Option value="informational">Informational</Option>
              <Option value="commercial">Commercial</Option>
              <Option value="transactional">Transactional</Option>
              <Option value="navigational">Navigational</Option>
            </Select>
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="require_question_keywords" label="Require Question Keywords" valuePropName="checked">
            <Switch />
          </Form.Item>
        </Col>
        <Col span={24}>
          <Form.Item name="negative_keywords" label="Negative Keywords" extra="Comma-separated list of keywords to exclude (e.g., free, login)">
            <Input.TextArea rows={2} />
          </Form.Item>
        </Col>
      </Row>

      <Divider /><br/>
      <Title level={5}>SERP & Competitor Analysis Cost Controls</Title><br/>
      <Row gutter={16}><br/>
        <Col span={12}><br/>
          <Form.Item name="load_async_ai_overview" label="Load Async AI Overview" valuePropName="checked" tooltip="Set to true to obtain AI Overview items in SERPs even if they are loaded asynchronously. Costs $0.002 extra per SERP call."><br/>
            <Switch checkedChildren="Enabled" unCheckedChildren="Disabled" /><br/>
          </Form.Item><br/>
        </Col><br/>
        <Col span={12}><br/>
          <Form.Item name="people_also_ask_click_depth" label="PAA Click Depth"><br/>
            <InputNumber min={0} max={4} style={{ width: '100%' }} tooltip="Specify the depth of clicks (1 to 4) on People Also Ask elements. Costs $0.00015 extra per click per level." /><br/>
          </Form.Item><br/>
        </Col><br/>
        <Col span={12}><br/>
          <Form.Item name="onpage_enable_browser_rendering" label="Enable Browser Rendering (High Cost)" valuePropName="checked" tooltip="If true, emulates a full browser load for Core Web Vitals (LCP/CLS) and loads JavaScript/Resources automatically. Primary cost factor for Analysis."><br/>
            <Switch checkedChildren="Enabled" unCheckedChildren="Disabled" /><br/>
          </Form.Item><br/>
        </Col><br/>
        <Col span={12}><br/>
          <Form.Item name="onpage_enable_custom_js" label="Enable Custom JavaScript" valuePropName="checked" tooltip="Allows execution of custom JavaScript during OnPage crawl. Costs $0.00025 extra per page analyzed."><br/>
            <Switch checkedChildren="Enabled" unCheckedChildren="Disabled" /><br/>
          </Form.Item><br/>
        </Col><br/>
      </Row><br/><br/>
    </>
  );
};

export default DiscoverySettingsTab;
```

## File: src/pages/Settings/tabs/ScoringWeightsTab.jsx
```javascript
// This is a new file. Create it with the following content:
import React from 'react';
import { Form, Slider, InputNumber, Typography, Row, Col, Divider, Tooltip, Space, Alert } from 'antd';
import { InfoCircleOutlined } from '@ant-design/icons';

const { Title, Text } = Typography;

const ScoringWeightsTab = ({ settings, form }) => {
  const allWeights = Form.useWatch([
    'ease_of_ranking_weight',
    'traffic_potential_weight',
    'commercial_intent_weight',
    'serp_features_weight',
    'growth_trend_weight',
    'serp_freshness_weight',
    'serp_volatility_weight',
    'competitor_weakness_weight'
  ], form);

  const totalWeight = Object.values(allWeights || {}).reduce((sum, current) => sum + (current || 0), 0);

  const renderWeightInput = (name, label, tooltip) => (
    <Col span={24}>
      <Form.Item 
        name={name} 
        label={
          <Space>
            {label}
            {tooltip && <Tooltip title={tooltip}><InfoCircleOutlined /></Tooltip>}
          </Space>
        }
        rules={[{ required: true, message: 'Weight is required' }]}
        style={{ marginBottom: 0 }}
      >
        <Row>
          <Col span={18}>
            <Slider min={0} max={100} step={1} style={{ margin: '0 8px' }} />
          </Col>
          <Col span={4}>
            <InputNumber min={0} max={100} step={1} style={{ width: '100%' }} />
          </Col>
        </Row>
      </Form.Item>
    </Col>
  );

  return (
    <>
      <Title level={5}>Strategic Scoring Weights (Sum to {totalWeight}%)</Title>
      {totalWeight !== 100 && (
        <Alert
          message="Warning: Total weight is not 100%"
          description="The sum of all weights should ideally be 100% for proper normalization. Consider adjusting your weights."
          type="warning"
          showIcon
          style={{ marginBottom: '16px' }}
        />
      )}
      <Row gutter={16}>
        {renderWeightInput('ease_of_ranking_weight', 'Ease of Ranking', 'How easy it is to rank (based on KD, backlinks).')}
        {renderWeightInput('traffic_potential_weight', 'Traffic Potential', 'How much traffic the keyword can bring (based on Search Volume).')}
        {renderWeightInput('commercial_intent_weight', 'Commercial Intent', 'How likely the keyword is to lead to a conversion (based on CPC, intent type).')}
        {renderWeightInput('serp_features_weight', 'SERP Features', 'Impact of rich SERP features (Featured Snippets, AI Overviews).')}
        {renderWeightInput('growth_trend_weight', 'Growth Trend', 'How quickly the search volume is growing or declining.')}
        {renderWeightInput('serp_freshness_weight', 'SERP Freshness', 'How recently the SERP was updated (opportunity if stale).')}
        {renderWeightInput('serp_volatility_weight', 'SERP Volatility', 'How often the SERP changes (opportunity if stable).')}
        {renderWeightInput('competitor_weakness_weight', 'Competitor Weakness', 'Exploitable technical or content flaws of top competitors.')}
      </Row>

      <Divider />

      <Title level={5}>Scoring Normalization Values</Title>
      <Row gutter={16}>
        <Col span={12}>
          <Form.Item name="max_cpc_for_scoring" label="Max CPC for Scoring">
            <InputNumber min={0.0} step={1.0} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_sv_for_scoring" label="Max Search Volume for Scoring">
            <InputNumber min={0} step={1000} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_domain_rank_for_scoring" label="Max Domain Rank for Scoring">
            <InputNumber min={0} step={100} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
        <Col span={12}>
          <Form.Item name="max_referring_domains_for_scoring" label="Max Referring Domains for Scoring">
            <InputNumber min={0} step={50} style={{ width: '100%' }} />
          </Form.Item>
        </Col>
      </Row>
    </>
  );
};

export default ScoringWeightsTab;
```

## File: src/pages/Settings/SettingsPage.jsx
```javascript
// This is a new file. Create it with the following content:
import React, { useState, useEffect } from 'react';
import { Layout, Typography, Tabs, Spin, Alert, Button, Space, Form } from 'antd';
import { useQuery, useMutation, useQueryClient } from 'react-query';
import { getClientSettings, updateClientSettings } from '../../services/clientSettingsService'; // Corrected
import { useClient } from '../../hooks/useClient'; // NEW
import { useNotifications } from '../../context/NotificationContext'; // NEW
import { SaveOutlined, ReloadOutlined } from '@ant-design/icons';
import DiscoverySettingsTab from './tabs/DiscoverySettingsTab'; // NEW
import ScoringWeightsTab from './tabs/ScoringWeightsTab'; // NEW
import AiContentSettingsTab from './tabs/AiContentSettingsTab'; // NEW

const { Content } = Layout;
const { Title, Text } = Typography;

// Placeholder tab components
const ApiKeysSettingsTab = ({ settings, form }) => <Alert message="API Keys" description="API key management will go here." type="info" />; // NEW for task 3.3.1 (API Key Management)

const SettingsPage = () => {
  console.log('Rendering SettingsPage');
  const { clientId } = useClient();
  const { showNotification } = useNotifications();
  const queryClient = useQueryClient();
  const [form] = Form.useForm();
  const [isDirty, setIsDirty] = useState(false); // To track if form has unsaved changes

  const { data: currentSettings, isLoading, isError, error, refetch } = useQuery(
    ['clientSettings', clientId],
    () => getClientSettings(clientId),
    {
      enabled: !!clientId,
      onSuccess: (data) => {
        form.setFieldsValue(data); // Populate form with fetched settings
        setIsDirty(false); // Reset dirty state on successful fetch/load
      },
      onError: (err) => {
        showNotification('error', 'Failed to Load Settings', err.message || 'An error occurred while loading settings.');
      },
      staleTime: 5 * 60 * 1000, // Consider settings stale after 5 minutes
    }
  );

  const { mutate: saveSettingsMutation, isLoading: isSavingSettings } = useMutation(
    (updatedSettings) => updateClientSettings(clientId, updatedSettings),
    {
      onSuccess: () => {
        showNotification('success', 'Settings Saved', 'Client settings updated successfully.');
        setIsDirty(false); // Mark as clean after saving
        queryClient.invalidateQueries(['clientSettings', clientId]); // Invalidate to ensure fresh data if re-fetched elsewhere
      },
      onError: (err) => {
        showNotification('error', 'Save Failed', err.message || 'An error occurred while saving settings.');
      },
    }
  );

  const handleFormChange = () => {
    setIsDirty(true); // Mark form as dirty on any change
  };

  const handleSave = () => {
    form.validateFields()
      .then(values => {
        saveSettingsMutation(values);
      })
      .catch(info => {
        showNotification('error', 'Validation Error', 'Please correct the highlighted fields.');
        console.log('Validate Failed:', info);
      });
  };

  const handleResetToCurrent = () => {
    if (currentSettings) {
      form.setFieldsValue(currentSettings);
      setIsDirty(false);
      showNotification('info', 'Reset', 'Form reset to current saved settings.');
    }
  };

  if (isLoading) {
    return <Spin tip="Loading settings..." style={{ display: 'block', marginTop: '50px' }} />;
  }

  if (isError) {
    return <Alert message="Error" description={error?.message || "Failed to load settings."} type="error" showIcon />;
  }

  const tabItems = [
    {
      label: 'Discovery & Filtering',
      key: 'discovery',
      children: <DiscoverySettingsTab settings={currentSettings} form={form} />,
    },
    {
      label: 'Scoring & Weights',
      key: 'scoring',
      children: <ScoringWeightsTab settings={currentSettings} form={form} />,
    },
    {
      label: 'AI & Content Generation',
      key: 'ai-content',
      children: <AiContentSettingsTab settings={currentSettings} form={form} />,
    },
    {
      label: 'API Keys', // NEW tab
      key: 'api-keys',
      children: <ApiKeysSettingsTab settings={currentSettings} form={form} />,
    }
  ];

  return (
    <Layout style={{ padding: '24px' }}>
      <Content>
        <Title level={2}>Client Settings: {clientId}</Title>
        <Form
          form={form}
          layout="vertical"
          onValuesChange={handleFormChange}
          onFinish={handleSave}
          initialValues={currentSettings} // Set initial values from fetched data
        >
          <Tabs defaultActiveKey="discovery" items={tabItems} style={{ marginBottom: '24px' }} />

          <Space>
            <Button 
              type="primary" 
              htmlType="submit" 
              icon={<SaveOutlined />} 
              loading={isSavingSettings} 
              disabled={!isDirty || isSavingSettings}
            >
              Save Changes
            </Button>
            <Button 
              icon={<ReloadOutlined />} 
              onClick={handleResetToCurrent} 
              disabled={!isDirty || isSavingSettings}
            >
              Reset to Current
            </Button>
          </Space>
        </Form>
      </Content>
    </Layout>
  );
};

export default SettingsPage;
```

## File: src/services/apiClient.js
```javascript
import axios from 'axios';
import { ClientContext } from '../context/ClientContext'; // Import ClientContext

// Create an Axios instance for API communication
const apiClient = axios.create({
  // The base URL is handled by the Vite proxy, so we can use relative paths like /api
  headers: {
    'Content-Type': 'application/json', // Default content type for requests
  },
  // You could add a timeout here if desired
  // timeout: 10000, 
});

// Below the `axios.create` block, add the request interceptor:
apiClient.interceptors.request.use(
  (config) => {
    // Dynamically get the current client ID from localStorage
    const currentClientId = localStorage.getItem('currentClientId');
    if (currentClientId) {
      config.headers['X-Client-ID'] = currentClientId;
    }
    const token = localStorage.getItem('authToken');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Interceptor to handle successful responses
apiClient.interceptors.response.use(
  (response) => {
    // Axios wraps the actual data in a `data` property. We return just the data.
    return response.data;
  },
  (error) => {
    // Centralized error handling for all API calls
    console.error('API Error:', error.response || error.message);

    // Optionally, you could check for specific status codes (e.g., 401 for unauthorized)
    // and trigger global actions like showing a notification or redirecting to login.
    // if (error.response && error.response.status === 401) {
    //   // handle unauthorized
    // }

    // If the error is an AbortError from AbortController, do not treat it as a critical failure
    if (axios.isCancel(error) || error.code === 'ERR_CANCELED') {
        // Propagate as a cancelled error for specific handling in components
        const cancelledError = new Error('Request was cancelled');
        cancelledError.name = 'CanceledError';
        return Promise.reject(cancelledError);
    }

    return Promise.reject(error); // Re-throw the error for component-specific handling
  }
);

export default apiClient;
```

## File: src/services/authService.js
```javascript
// This is a new file. Create it with the following content:
import apiClient from './apiClient';

/**
 * Sends login request to the backend.
 * @param {string} password - The user's password.
 * @returns {Promise<object>} A promise that resolves to the login response (user and token).
 */
export const login = (password) => {
  return apiClient.post('/api/auth/login', { password });
};

/**
 * Sends logout request to the backend.
 * @returns {Promise<object>} A promise that resolves to the logout message.
 */
export const logout = () => {
  return apiClient.post('/api/auth/logout');
};
```

## File: src/services/clientService.js
```javascript
// This is a new file. Create it with the following content:
import apiClient from './apiClient';

/**
 * Fetches a list of all clients.
 * @returns {Promise<Array>} A promise that resolves to an array of client objects.
 */
export const getClients = () => {
  return apiClient.get('/api/clients');
};

/**
 * Fetches dashboard statistics for a specific client.
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<Object>} A promise that resolves to the dashboard stats object.
 */
export const getDashboardStats = (clientId) => {
  return apiClient.get(`/api/clients/${clientId}/dashboard-stats`);
};

/**
 * Adds a new client to the system.
 * @param {Object} clientData - The data for the new client (client_id, client_name).
 * @returns {Promise<Object>} A promise that resolves to the new client's data.
 */
export const addClient = (clientData) => {
  return apiClient.post('/api/clients', clientData);
};


/**
 * Searches across all client-specific assets (opportunities, runs, etc.).
 * @param {string} clientId - The ID of the client.
 * @param {string} query - The search query.
 * @returns {Promise<Array>} A promise that resolves to an array of search results.
 */
export const searchAllAssets = (clientId, query) => {
  return apiClient.get(`/api/clients/${clientId}/search-all-assets?query=${encodeURIComponent(query)}`);
};

/**
 * Fetches aggregated data for the main dashboard.
 * @param {string} clientId - The ID of the client.
 * @returns {Promise<Object>} A promise that resolves to the dashboard data object.
 */
export const getDashboardData = (clientId) => {
  return apiClient.get(`/api/clients/${clientId}/dashboard`);
};
```

## File: src/services/clientSettingsService.js
```javascript
// my-content-app/src/services/clientSettingsService.js
// NEW FILE
import apiClient from './apiClient';

export const getClientSettings = (clientId) => {
  return apiClient.get(`/api/settings/${clientId}`);
};

export const updateClientSettings = (clientId, settings) => {
  return apiClient.put(`/api/settings/${clientId}`, settings);
};
```

## File: src/services/discoveryService.js
```javascript
import apiClient from './apiClient';

export const startDiscoveryRun = ({ clientId, runData }) => {
  return apiClient.post(`/api/clients/${clientId}/discovery-runs-async`, runData);
};

export const getDiscoveryRuns = (clientId, page = 1) => {
  return apiClient.get(`/api/clients/${clientId}/discovery-runs`, { params: { page } });
};

export const estimateCost = ({ clientId, seed_keywords, signal }) => {
  return apiClient.post(`/api/discovery/estimate-cost`, { seed_keywords }, { signal });
};

export const preCheckKeywords = ({ clientId, seed_keywords, signal }) => {
  return apiClient.post(`/api/discovery/pre-check`, { seed_keywords }, { signal });
};

export const rerunDiscoveryRun = (runId) => {
  return apiClient.post(`/api/discovery-runs/rerun/${runId}`);
};

export const getKeywordsForRun = (runId) => {
  return apiClient.get(`/api/discovery-runs/${runId}/keywords`);
};

export const getDisqualifiedKeywords = (runId, reason) => {
    return apiClient.get(`/api/discovery-runs/${runId}/keywords/${reason}`);
};

export const getDisqualificationReasons = (runId) => {
  return apiClient.get(`/api/discovery-runs/${runId}/disqualification-reasons`);
};

export const getJobStatus = (jobId) => {
  return apiClient.get(`/api/jobs/${jobId}`);
};

export const getOpportunities = (clientId, { page = 1, limit = 50, status = 'qualified', sort_by = 'strategic_score', sort_direction = 'desc' }) => {
  return apiClient.get(`/api/clients/${clientId}/opportunities`, { 
    params: { page, limit, status, sort_by, sort_direction } 
  });
};

export const getDiscoveryRunById = async (runId) => {
  const response = await apiClient.get(`/discovery/runs/${runId}`);
  return response;
};
```

## File: src/services/jobsService.js
```javascript
import apiClient from './apiClient';

export const getJobStatus = (jobId) => {
  return apiClient.get(`/api/jobs/${jobId}`);
};
```

## File: src/services/opportunitiesService.js
```javascript
import apiClient from './apiClient';

export const getOpportunities = (clientId, params) => {
  return apiClient.get(`/api/clients/${clientId}/opportunities/summary`, { params });
};

export const getDashboardStats = (clientId) => {
  return apiClient.get(`/api/clients/${clientId}/dashboard`);
};

export const getOpportunityById = (id) => {
  return apiClient.get(`/api/opportunities/${id}`);
};

export const updateOpportunityStatus = (opportunityId, status) => {
  return apiClient.put(`/api/opportunities/${opportunityId}/status?status=${status}`);
};

export const bulkAction = (action, opportunityIds) => {
  return apiClient.post('/api/opportunities/bulk-action', { action, opportunity_ids: opportunityIds });
};

export const compareOpportunities = (opportunityIds) => {
  return apiClient.post('/api/opportunities/compare', { opportunity_ids: opportunityIds });
};

export const updateOpportunityAiContent = (id, updatedContent) => {
  return apiClient.put(`/api/opportunities/${id}/ai-content`, updatedContent);
};

export const generateImage = (id, prompt) => {
  return apiClient.post(`/api/opportunities/${id}/generate-image`, { prompt });
};

export const updateOpportunityImages = (id, images) => {
  return apiClient.put(`/api/opportunities/${id}/images`, images);
};

export const generateSocialPosts = (id, platforms) => {
  return apiClient.post(`/api/opportunities/${id}/generate-social-posts`, { platforms });
};

export const updateOpportunitySocialPosts = (id, posts) => {
  return apiClient.put(`/api/opportunities/${id}/social-posts`, { social_media_posts: posts });
};

export const getContentHistory = (opportunityId) => {
  return apiClient.get(`/api/opportunities/${opportunityId}/content-history`);
};

export const restoreContentVersion = (opportunityId, versionTimestamp) => {
  return apiClient.post(`/api/opportunities/${opportunityId}/restore-content`, { version_timestamp: versionTimestamp });
};

export const submitContentFeedback = (opportunityId, feedbackData) => {
  return apiClient.post(`/api/opportunities/${opportunityId}/feedback`, feedbackData);
};

export const overrideDisqualification = (opportunityId) => {
  return apiClient.post(`/api/opportunities/${opportunityId}/override-disqualification`);
};

export const updateOpportunityContent = (opportunityId, newContentPayload) => {
  return apiClient.put(`/api/opportunities/${opportunityId}/content`, newContentPayload);
};

export const approveAnalysis = (opportunityId, overrides) => {
  return apiClient.post(`/api/orchestrator/approve-analysis/${opportunityId}`, overrides);
};
```

## File: src/services/orchestratorService.js
```javascript
import apiClient from './apiClient';

export const runAnalysis = (opportunityId, selectedUrls) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/run-analysis-async`, { selected_competitor_urls: selectedUrls });
};

export const startFullContentGeneration = (opportunityId, modelOverride = null, temperature = null) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/run-generation-async`, { model_override: modelOverride, temperature: temperature });
};

export const approveAnalysis = (opportunityId, overrides = null) => {
  const payload = {
    overrides: {
      additional_instructions: JSON.stringify(overrides),
    },
  };
  return apiClient.post(`/api/orchestrator/approve-analysis/${opportunityId}`, payload);
};

export const refreshContentWorkflow = (opportunityId) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/refresh-content-async`);
};

export const startFullAnalysis = (opportunityId, modelOverride) => {
    return apiClient.post(`/api/orchestrator/run-full-analysis/${opportunityId}`, { model_override: modelOverride });
};

export const getJobStatus = (jobId) => {
    return apiClient.get(`/api/jobs/${jobId}/status`);
};

export const estimateActionCost = (actionType, opportunityId = null, discoveryParams = null) => {
  const url = opportunityId 
    ? `/api/orchestrator/estimate-cost/${opportunityId}` 
    : '/api/orchestrator/estimate-cost';
  
  const payload = {
    action_type: actionType,
    discovery_params: discoveryParams,
  };
  
  return apiClient.post(url, payload);
};

export const getSerpDataLive = (opportunityId) => {
    return apiClient.get(`/api/orchestrator/${opportunityId}/serp-preview`);
};

export const refreshSerpData = (opportunityId) => {
            return apiClient.post(`/api/orchestrator/${opportunityId}/rerun-analysis-async`);
        };
export const getAllJobs = () => {
    return apiClient.get('/api/jobs');
};

export const cancelJob = (jobId) => {
    return apiClient.post(`/api/jobs/${jobId}/cancel`);
};

// Update startFullWorkflow to accept overrideValidation
export const startFullWorkflow = (opportunityId, overrideValidation = false) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/run-full-auto-async`, {
    override_validation: overrideValidation
  });
};

// Add refineContent to call the backend refinement endpoint
export const refineContent = (opportunityId, htmlContent, command) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/refine-content`, {
    html_content: htmlContent,
    command: command
  });
};

export const generateContentOverride = (opportunityId) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/generate-content-override`);
};

// New service function to reject an opportunity
export const rejectOpportunity = (opportunityId) => {
  return apiClient.post(`/api/orchestrator/reject-opportunity/${opportunityId}`);
};

export const updateSocialMediaPostsStatus = (opportunityId, newStatus) => {
  return apiClient.post(`/api/orchestrator/${opportunityId}/social-media-status`, { new_status: newStatus });
};

 // Add this new function

 export const startFullAutomationWorkflow = (opportunityId, overrideValidation = false) => {

   return apiClient.post(`/api/orchestrator/${opportunityId}/run-full-automation-async`, {

     override_validation: overrideValidation

   });

 };



 export const getFullPrompt = (opportunityId) => {



   return apiClient.get(`/api/orchestrator/${opportunityId}/full-prompt`);



 };



 



 export const getScoreNarrative = (opportunityId) => {



   return apiClient.get(`/api/orchestrator/${opportunityId}/score-narrative`);



 };
```

## File: src/services/settingsService.js
```javascript
import apiClient from './apiClient';

export const getDiscoveryStrategies = async () => {
  // This is a placeholder. In a real app, you might fetch this from the backend.
  return ["Keyword Ideas", "Keyword Suggestions", "Related Keywords"];
};

export const getAvailableDiscoveryFilters = async () => {
  return apiClient.get('/api/discovery/available-filters');
};
```

## File: src/App.jsx
```javascript
import React from 'react';
import { Routes, Route } from 'react-router-dom';
import MainLayout from './components/layout/MainLayout';
import DiscoveryPage from './pages/DiscoveryPage/DiscoveryPage';
import RunDetailsPage from './pages/RunDetailsPage/RunDetailsPage';
import OpportunitiesPage from './pages/OpportunitiesPage/OpportunitiesPage';
import { useAuth } from './context/AuthContext';
import LoginPage from './pages/Auth/LoginPage';
import { Spin } from 'antd'; // For loading state
import DashboardPage from './pages/Dashboard/DashboardPage';
import ClientDashboardPage from './pages/ClientDashboard/ClientDashboardPage';
import OpportunityDetailPage from './pages/opportunity-detail-page/index.jsx';
import ActivityLogPage from './pages/ActivityLog/ActivityLogPage';
import SettingsPage from './pages/Settings/SettingsPage';
import NotFoundPage from './pages/NotFoundPage/NotFoundPage';

import { JobProvider } from './context/JobContext';
import BlogPage from './pages/BlogPage/BlogPage';

// REPLACE the existing `function App() { ... }` block with this:
function App() {
  const { isAuthenticated, loading } = useAuth();

  if (loading) {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <Spin size="large" tip="Loading authentication..." />
      </div>
    );
  }

  return (
    <Routes>
      {isAuthenticated ? (
        <>
          <Route path="/" element={<MainLayout />}>
            <Route index element={<DashboardPage />} />
            <Route path="/dashboard" element={<DashboardPage />} />
            <Route path="/clients" element={<ClientDashboardPage />} />
            <Route path="/opportunities" element={<OpportunitiesPage />} />
            <Route path="/opportunities/:opportunityId" element={<OpportunityDetailPage />} />
            <Route path="/discovery/run/:runId" element={<RunDetailsPage />} />
            <Route path="/activity-log" element={<ActivityLogPage />} />
            <Route path="/settings" element={<SettingsPage />} />
            <Route path="/discovery" element={<DiscoveryPage />} />
            <Route path="*" element={<NotFoundPage />} />
          </Route>
          <Route path="/blog/:opportunityId" element={<BlogPage />} />
        </>
      ) : (
        <>
          <Route path="/login" element={<LoginPage />} />
          <Route path="*" element={<LoginPage />} />
        </>
      )}
    </Routes>
  );
}

export default App;
```

## File: src/index.css
```css
/* Global styles for the application */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: #f0f2f5; /* Light grey background for the app */
}

/* Add specific Ant Design overrides if needed */
/* For example, to make tags slightly smaller globally */
.ant-tag {
  font-size: 12px;
  height: auto;
  line-height: 1.8;
  padding: 0 7px;
}
```

## File: src/main.jsx
```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ClientProvider } from './context/ClientContext';
import { NotificationProvider } from './context/NotificationContext';
import { AuthProvider } from './context/AuthContext';
import App from './App';
import 'antd/dist/reset.css'; // Ant Design's base styles
import './index.css'; // Your global custom styles

import { JobProvider } from './context/JobContext';
import GlobalJobTracker from './components/GlobalJobTracker';

// ... (other imports)

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false, // Don't refetch automatically on window focus
      retry: 1, // Retry failed queries once
    },
  },
});

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <BrowserRouter>
      <QueryClientProvider client={queryClient}>
        <NotificationProvider>
          <AuthProvider>
            <ClientProvider>
              <JobProvider>
                <App />
                <GlobalJobTracker />
              </JobProvider>
            </ClientProvider>
          </AuthProvider>
        </NotificationProvider>
      </QueryClientProvider>
    </BrowserRouter>
  </React.StrictMode>
);
```

## File: .dockerignore
```
# Ignore dependencies, as they are installed inside the container
node_modules

# Ignore build output
dist
build

# Ignore miscellaneous files
.env
.eslintignore
.eslintrc.json
npm-debug.log
README.md
```

## File: .eslintignore
```
/node_modules
/dist
/vite.config.js
/.eslintrc.json
```

## File: .eslintrc.json
```json
{
    "env": {
        "browser": true,
        "es2021": true
    },
    "extends": [
        "eslint:recommended",
        "plugin:react/recommended",
        "plugin:react-hooks/recommended"
    ],
    "parserOptions": {
        "ecmaFeatures": {
            "jsx": true
        },
        "ecmaVersion": 12,
        "sourceType": "module"
    },
    "plugins": [
        "react",
        "react-hooks"
    ],
    "rules": {
        "react/prop-types": "off"
    },
    "settings": {
        "react": {
            "version": "detect"
        }
    }
}
```

## File: Dockerfile
```dockerfile
# Stage 1: Build the React application
FROM node:18-alpine as build

WORKDIR /app

COPY package.json ./

RUN npm install --legacy-peer-deps

COPY . .

RUN npm run build

# Stage 2: Serve the application with Nginx
FROM nginx:stable-alpine

# Copy the built files from the build stage
COPY --from=build /app/dist /usr/share/nginx/html

# Copy the custom Nginx configuration
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Expose port 80
EXPOSE 80

# Start Nginx
CMD ["nginx", "-g", "daemon off;"]
```

## File: index.html
```html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
```

## File: nginx.conf
```
server {
  listen 80;

  location / {
    root   /usr/share/nginx/html;
    index  index.html index.htm;
    try_files $uri $uri/ /index.html;
  }

  location /api {
    proxy_pass http://backend:8000;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
  }

  error_page   500 502 503 504  /50x.html;
  location = /50x.html {
    root   /usr/share/nginx/html;
  }
}
```

## File: package.json
```json
{
  "name": "my-content-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint . --ext js,jsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "@ant-design/charts": "^2.6.5",
    "@ant-design/icons": "^5.3.7",
    "antd": "^5.17.4",
    "axios": "^1.7.2",
    "date-fns": "^3.6.0",
    "file-saver": "^2.0.5",
    "jszip": "^3.10.1",
    "react": "^18.2.0",
    "react-diff-viewer": "^3.1.1",
    "react-dom": "^18.2.0",
    "react-query": "^3.39.3",
    "react-quill": "^2.0.0",
    "react-router-dom": "^6.23.1",
    "recharts": "^2.12.7"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react": "^7.34.1",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "vite": "^5.2.0"
  }
}
```

## File: vite.config.js
```javascript
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3000, // Frontend will run on port 3000
    proxy: {
      // Proxy API requests to the FastAPI backend
      '/api': {
        target: 'http://localhost:8000', // Backend address
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''), // Strip /api prefix
      },
    },
  },
});
```
